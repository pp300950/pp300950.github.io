<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ไพ่นกกระจอกกับบอท</title>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background-color: #f0f0f0;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
      }

      .game-container {
        background-color: #fff;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        padding: 25px;
        text-align: center;
        width: 100%;
        max-width: 900px; /* จำกัดความกว้างสูงสุด */
        box-sizing: border-box;
      }

      h1,
      h2 {
        color: #333;
        margin-bottom: 15px;
      }

      .board {
        display: flex;
        flex-direction: column; /* จัดเรียงเป็นคอลัมน์ในมือถือ */
        gap: 20px;
        margin-top: 20px;
      }

      @media (min-width: 768px) {
        /* สำหรับแท็บเล็ตและคอมพิวเตอร์ */
        .board {
          flex-direction: row; /* จัดเรียงเป็นแถวบนจอใหญ่ */
          justify-content: space-around;
          align-items: flex-start;
        }
      }

      .player {
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 15px;
        background-color: #f9f9f9;
        flex: 1; /* ให้แต่ละส่วนขยายเต็มพื้นที่ */
      }

      .tile-hand,
      .tile-area,
      .open-melds {
        display: flex;
        flex-wrap: wrap;
        gap: 8px; /* ระยะห่างระหว่างไพ่ */
        justify-content: center;
        min-height: 60px; /* ให้มีพื้นที่เพียงพอ */
      }

      .open-melds {
        border-top: 1px dashed #ddd;
        margin-top: 10px;
        padding-top: 10px;
        font-size: 0.9em;
      }

      .meld-group {
        display: flex;
        gap: 2px;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        padding: 2px;
        margin: 2px;
      }

      .tile {
        font-size: 32px; /* ขนาด Emoji */
        line-height: 1;
        cursor: pointer;
        padding: 5px;
        border: 1px solid #eee;
        border-radius: 4px;
        background-color: #fff;
        transition: transform 0.1s ease-in-out;
      }

      .tile:hover {
        transform: translateY(-3px);
      }

      .discard-pile {
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 15px;
        background-color: #f9f9f9;
        flex: 2; /* ส่วนไพ่ที่ทิ้งอาจจะใหญ่ขึ้น */
      }

      .actions {
        margin-top: 15px;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
      }

      .actions button {
        background-color: #4caf50;
        color: white;
        padding: 10px 15px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.2s;
      }

      .actions button:hover:not(:disabled) {
        background-color: #45a049;
      }

      .actions button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }

      .dynamic-actions {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
      }

      .dynamic-actions button {
        background-color: #008cba; /* สีฟ้าสำหรับ Chi/Pon/Kan */
      }

      .dynamic-actions button:hover:not(:disabled) {
        background-color: #007bb5;
      }

      .message {
        margin-top: 20px;
        padding: 10px;
        background-color: #e7f3e7;
        border: 1px solid #d4edda;
        color: #155724;
        border-radius: 5px;
      }

      /* ปรับขนาด Emoji สำหรับหน้าจอมือถือ */
      @media (max-width: 500px) {
        .tile {
          font-size: 24px; /* ลดขนาด Emoji ลง */
          padding: 3px;
        }
        .actions button {
          padding: 8px 12px;
          font-size: 14px;
        }
        .game-container {
          padding: 15px;
        }
      }

      /* Style สำหรับข้อมูลเกมส่วนล่าง */
      .game-info {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-around;
        gap: 10px;
        padding: 10px;
        background-color: #e0f2f7; /* สีฟ้าอ่อน */
        border-radius: 8px;
        font-size: 1.1em;
      }
      .game-info div {
        padding: 5px 10px;
        border-radius: 4px;
        background-color: #c7e8ed;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>เกมไพ่นกกระจอก</h1>

      <div class="board">
        <div class="player bot-hand">
          <h2>บอท</h2>
          <div id="bot-tiles" class="tile-hand"></div>
          <div id="bot-open-melds" class="open-melds"></div>
        </div>

        <div class="discard-pile">
          <h2>ไพ่ที่ทิ้ง</h2>
          <div id="discarded-tiles" class="tile-area"></div>
        </div>

        <div class="player user-hand">
          <h2>คุณ</h2>
          <div id="user-tiles" class="tile-hand"></div>
          <div id="user-open-melds" class="open-melds"></div>
        </div>
      </div>

      <div class="game-info">
        <div id="user-score">คะแนนคุณ: 25000</div>
        <div id="bot-score">คะแนนบอท: 25000</div>
        <div id="round-info">
          <span id="round-wind">ลมรอบ: 東</span>
          |
          <span id="player-wind">ลมคุณ: 東</span>
          |
          <span id="kyoutaku-sticks">Kyoutaku: 0x1000</span>
          |
          <span id="honba-count">Honba: 0</span>
        </div>
        <div id="dora-indicators">Dora Indicators:</div>
        <div id="dead-wall-count">ไพ่ในสำรับที่เหลือ:</div>
      </div>

      <div class="actions">
        <button id="draw-tile-btn" disabled>จั่วไพ่</button>
        <button id="riichi-btn" disabled>Riichi</button>
        <button id="tsumo-btn" style="display: none">Tsumo</button>
        <button id="ron-btn" style="display: none">Ron</button>
        <div id="dynamic-actions" class="dynamic-actions"></div>
      </div>

      <div id="game-message" class="message">
        เกมเริ่มต้นแล้ว! คุณสามารถจั่วไพ่ได้
      </div>
    </div>
    <script>
      const TILES = {
        characters: ['🀇', '🀈', '🀉', '🀊', '🀋', '🀌', '🀍', '🀎', '🀏'], // 1-9 Man
        dots: ['🀙', '🀚', '🀛', '🀜', '🀝', '🀞', '🀟', '🀠', '🀡'], // 1-9 Pin
        bamboos: ['🀐', '🀑', '🀒', '🀓', '🀔', '🀕', '🀖', '🀗', '🀘'], // 1-9 Sou
        winds: ['🀀', '🀁', '🀂', '🀃'], // East, South, West, North
        dragons: ['🀄', '🀅', '🀆'], // Red, Green, White
      };

      let deck = [];
      let userHand = [];
      let botHand = [];
      // เปลี่ยนโครงสร้างของ openMelds ให้เก็บประเภทของ Meld ด้วย
      // เช่น { type: 'pon', tiles: ['🀇', '🀇', '🀇'] }
      // หรือสำหรับ Kan: { type: 'minkan', tiles: ['🀇', '🀇', '🀇', '🀇'] }
      // หรือ { type: 'ankan', tiles: ['🀇', '🀇', '🀇', '🀇'] }
      let userOpenMelds = [];
      let botOpenMelds = [];
      let discardedTiles = [];
      let lastDiscardedTile = null;
      let lastDiscarder = null; // เพิ่มตัวแปรเพื่อระบุว่าใครทิ้งไพ่ล่าสุด (สำคัญสำหรับ Chi)
      let currentTurn = 'user'; // 'user' or 'bot' or 'user_action_check' or 'bot_action_check'
      let isUserDiscardPhase = false; // true เมื่อผู้เล่นจั่วไพ่แล้วและต้องทิ้งไพ่
      let isRiichiDeclared = { user: false, bot: false }; // สถานะ Riichi ของผู้เล่นและบอท
      let deadWall = []; // ไพ่ Dead Wall (สำหรับ Rinshan Kaihou, Dora)
      let doraIndicators = []; // ไพ่ Dora Indicators

      const userTilesEl = document.getElementById('user-tiles');
      const botTilesEl = document.getElementById('bot-tiles');
      const discardedTilesEl = document.getElementById('discarded-tiles');
      const userOpenMeldsEl = document.getElementById('user-open-melds');
      const botOpenMeldsEl = document.getElementById('bot-open-melds');
      const drawTileBtn = document.getElementById('draw-tile-btn');
      const riichiBtn = document.getElementById('riichi-btn');
      const gameMessageEl = document.getElementById('game-message');
      const dynamicActionsEl = document.getElementById('dynamic-actions');

      let playerScores = {
        user: 25000, // คะแนนเริ่มต้นของผู้เล่น
        bot: 25000, // คะแนนเริ่มต้นของบอท (สมมติว่ามีแค่ 2 คนในตอนนี้)
      };

      let roundWind = '🀀'; // ลมประจำรอบ (東 - East)
      let playerWind = {
        user: '🀀', // ลมประจำตัวผู้เล่น (東 - East)
        bot: '🀁', // ลมประจำตัวบอท (南 - South) - สำหรับ 2 ผู้เล่น บอทจะเป็น South
      };
      let isDealer = {
        user: true, // กำหนดว่าผู้เล่นเป็น Dealer (親 - Oya)
        bot: false,
      };

      // HTML Elements สำหรับแสดงคะแนน
      const userScoreEl = document.getElementById('user-score'); // ต้องมีใน HTML
      const botScoreEl = document.getElementById('bot-score'); // ต้องมีใน HTML

      // HTML Elements สำหรับปุ่ม Tsumo/Ron (คุณต้องเพิ่มใน index.html ของคุณ)
      const tsumoBtn = document.getElementById('tsumo-btn');
      const ronBtn = document.getElementById('ron-btn');

      // Helper to get all possible tiles in order (for sorting and Chi logic)
      const ALL_TILES_ORDER = [].concat(
        TILES.characters,
        TILES.dots,
        TILES.bamboos,
        TILES.winds,
        TILES.dragons
      );

      // --- ฟังก์ชันเริ่มต้นเกม ---
      function initializeGame() {
        deck = [];
        userHand = [];
        botHand = [];
        userOpenMelds = [];
        botOpenMelds = [];
        discardedTiles = [];
        lastDiscardedTile = null;
        lastDiscarder = null;
        isUserDiscardPhase = false;
        isRiichiDeclared = { user: false, bot: false }; // รีเซ็ตสถานะ Riichi
        deadWall = [];
        doraIndicators = [];

        createDeck();
        shuffleDeck();
        setupDeadWall(); // ตั้งค่า Dead Wall และ Dora
        dealTiles();
        renderHands();
        updateGameMessage('เกมเริ่มต้นแล้ว! คุณสามารถจั่วไพ่ได้');
        drawTileBtn.disabled = false;
        riichiBtn.disabled = true;
        currentTurn = 'user';
        clearDynamicActions();

        playerScores = { user: 25000, bot: 25000 }; // รีเซ็ตคะแนน
        roundWind = '🀀'; // รีเซ็ตลมรอบ
        playerWind = { user: '🀀', bot: '🀁' }; // รีเซ็ตลมผู้เล่น
        isDealer = { user: true, bot: false }; // รีเซ็ต Dealer

        updateScoresDisplay(); // แสดงคะแนนเริ่มต้น
        hideWinButtons(); // ซ่อนปุ่มชนะเมื่อเริ่มเกมใหม่
      }

      // Helper function: Counts occurrences of each tile in a hand
      function countTilesInHand(hand) {
        const counts = {};
        for (const tile of hand) {
          counts[tile] = (counts[tile] || 0) + 1;
        }
        return counts;
      }

      // Helper function: Checks if a tile is a simple tile (2-8 of numbers)
      function isSimpleTile(tile) {
        const type = getTileType(tile);
        const value = getTileValue(tile);
        return (
          (type === 'characters' || type === 'dots' || type === 'bamboos') &&
          value >= 2 &&
          value <= 8
        );
      }

      // Helper function: Checks if a tile is a terminal tile (1 or 9 of numbers)
      function isTerminalTile(tile) {
        const type = getTileType(tile);
        const value = getTileValue(tile);
        return (
          (type === 'characters' || type === 'dots' || type === 'bamboos') &&
          (value === 1 || value === 9)
        );
      }

      // Helper function: Checks if a tile is an honor tile (winds or dragons)
      function isHonorTile(tile) {
        return TILES.winds.includes(tile) || TILES.dragons.includes(tile);
      }

      // Main function to find winning patterns (4 groups and 1 pair, or special hands)
      // This is a recursive function that tries to form groups from the hand.
      function findWinningPattern(hand, melds = [], pair = null) {
        // Sort the hand to make processing easier
        sortHand(hand);

        // Base case: If no tiles left, a valid pattern is found
        if (hand.length === 0) {
          return {
            type: 'standard', // Standard 4 groups and 1 pair
            details: {
              melds: melds,
              pair: pair,
              fullHand: hand, // This will be the original full hand for reference
            },
          };
        }

        // --- Check for special winning patterns first (if not already handled) ---
        // These typically don't follow the 4 groups + 1 pair rule
        // NOTE: Chiitoitsu and Kokushi Musou checks are usually done *before* calling this function,
        // or within `isWinningHand` to return early.
        // For simplicity, this `findWinningPattern` focuses on standard hands.

        // If a pair has not been found yet, try to find one
        if (pair === null) {
          for (let i = 0; i < hand.length; i++) {
            if (hand[i] === hand[i + 1]) {
              // Found a pair
              const remainingHand = [...hand];
              remainingHand.splice(i, 2); // Remove the pair
              const result = findWinningPattern(remainingHand, melds, hand[i]);
              if (result) {
                // Attach the original fullHand for consistency
                result.details.fullHand = [
                  ...hand,
                  ...melds.flat(),
                  pair,
                ].sort(); // Reconstruct for full reference
                return result;
              }
            }
          }
        } else {
          // If a pair is already found, try to form melds
          const counts = countTilesInHand(hand);
          const uniqueTiles = Object.keys(counts).sort(
            (a, b) => getTileValue(a) - getTileValue(b)
          );

          for (const tile of uniqueTiles) {
            // Try to form a triplet (Pon)
            if (counts[tile] >= 3) {
              const remainingHand = [];
              for (const t in counts) {
                if (t === tile) {
                  for (let k = 0; k < counts[t] - 3; k++) remainingHand.push(t);
                } else {
                  for (let k = 0; k < counts[t]; k++) remainingHand.push(t);
                }
              }
              const newMelds = [...melds, [tile, tile, tile]];
              const result = findWinningPattern(remainingHand, newMelds, pair);
              if (result) return result;
            }

            // Try to form a sequence (Chi)
            const type = getTileType(tile);
            const value = getTileValue(tile);
            if (
              (type === 'characters' ||
                type === 'dots' ||
                type === 'bamboos') &&
              value <= 7
            ) {
              const tile2 = TILES[type][value + 1];
              const tile3 = TILES[type][value + 2];

              if (
                counts[tile] >= 1 &&
                counts[tile2] >= 1 &&
                counts[tile3] >= 1
              ) {
                const remainingHand = [];
                for (const t in counts) {
                  if (t === tile) {
                    for (let k = 0; k < counts[t] - 1; k++)
                      remainingHand.push(t);
                  } else if (t === tile2) {
                    for (let k = 0; k < counts[t] - 1; k++)
                      remainingHand.push(t);
                  } else if (t === tile3) {
                    for (let k = 0; k < counts[t] - 1; k++)
                      remainingHand.push(t);
                  } else {
                    for (let k = 0; k < counts[t]; k++) remainingHand.push(t);
                  }
                }
                const newMelds = [...melds, [tile, tile2, tile3]];
                const result = findWinningPattern(
                  remainingHand,
                  newMelds,
                  pair
                );
                if (result) return result;
              }
            }
          }
        }

        return null; // No winning pattern found
      }

      // Helper function to get the type of a tile (characters, dots, bamboos, winds, dragons)
      function getTileType(tile) {
        if (TILES.characters.includes(tile)) return 'characters';
        if (TILES.dots.includes(tile)) return 'dots';
        if (TILES.bamboos.includes(tile)) return 'bamboos';
        if (TILES.winds.includes(tile)) return 'winds';
        if (TILES.dragons.includes(tile)) return 'dragons';
        return null;
      }

      // Helper function to get the numeric value of a tile (1-9 for numbers, 0 for winds/dragons for sorting purposes)
      function getTileValue(tile) {
        let type = getTileType(tile);
        if (type === 'characters') return TILES.characters.indexOf(tile) + 1;
        if (type === 'dots') return TILES.dots.indexOf(tile) + 1;
        if (type === 'bamboos') return TILES.bamboos.indexOf(tile) + 1;
        // For winds and dragons, assign a numerical value for consistent sorting
        // Winds: East=1, South=2, West=3, North=4
        // Dragons: Red=1, White=2, Green=3
        if (type === 'winds') return TILES.winds.indexOf(tile) + 1;
        if (type === 'dragons') return TILES.dragons.indexOf(tile) + 1;
        return 0; // Should not happen for valid tiles
      }

      // --- ฟังก์ชัน sortHand ที่แก้ไขแล้ว ---
      function sortHand(hand) {
        // ตรวจสอบให้แน่ใจว่า hand เป็นอาร์เรย์ก่อนที่จะพยายาม sort
        if (!Array.isArray(hand)) {
          console.error('sortHand ได้รับค่าที่ไม่ใช่อาร์เรย์:', hand);
          return; // หรือจัดการข้อผิดพลาดตามความเหมาะสม
        }

        hand.sort((a, b) => {
          const typeA = getTileType(a);
          const typeB = getTileType(b);
          const valueA = getTileValue(a);
          const valueB = getTileValue(b);

          // กำหนดลำดับของประเภทไพ่ (เช่น Manzu ก่อน Pinzu ก่อน Souzu ก่อน Winds ก่อน Dragons)
          const typeOrder = {
            characters: 1,
            dots: 2,
            bamboos: 3,
            winds: 4,
            dragons: 5,
          };

          const orderA = typeOrder[typeA];
          const orderB = typeOrder[typeB];

          if (orderA !== orderB) {
            return orderA - orderB; // จัดเรียงตามประเภทไพ่
          } else {
            return valueA - valueB; // หากประเภทเดียวกัน ให้จัดเรียงตามค่าตัวเลข
          }
        });
      }

      // --- Update isWinningHand to use findWinningPattern ---
      function isWinningHand(hand) {
        // Always sort the hand for consistent processing
        sortHand(hand);
        const counts = countTilesInHand(hand);

        // 1. Check for Kokushi Musou (Thirteen Orphans)
        const kokushiTiles = [
          '🀇',
          '🀉',
          '🀐',
          '🀒',
          '🀙',
          '🀛', // Terminals 1,9 of Manzu, Pinzu, Souzu
          '🀀',
          '🀁',
          '🀂',
          '🀃', // Winds (East, South, West, North)
          '🀄',
          '🀅',
          '🀆', // Dragons (Red, White, Green)
        ];
        let hasAllKokushi = true;
        let hasPairInKokushi = false;
        for (const tile of kokushiTiles) {
          if (!counts[tile]) {
            hasAllKokushi = false;
            break;
          }
          if (counts[tile] >= 2) {
            hasPairInKokushi = true;
          }
        }
        if (hasAllKokushi && hasPairInKokushi && hand.length === 14) {
          return { type: 'kokushi_musou' };
        }

        // 2. Check for Chiitoitsu (Seven Pairs)
        let uniquePairs = 0;
        let isChiitoitsu = true;
        for (const tile in counts) {
          if (counts[tile] === 2) {
            uniquePairs++;
          } else if (counts[tile] !== 0) {
            // Should only have pairs
            isChiitoitsu = false;
            break;
          }
        }
        if (isChiitoitsu && uniquePairs === 7 && hand.length === 14) {
          return { type: 'chiitoitsu' };
        }

        // 3. Check for standard 4 groups and 1 pair
        // The recursive findWinningPattern tries to find this structure
        const standardPattern = findWinningPattern(hand);
        if (standardPattern) {
          return standardPattern;
        }

        return null; // No winning hand found
      }

      // ฟังก์ชันใหม่: แสดงคะแนนบน UI
      function updateScoresDisplay() {
        if (userScoreEl)
          userScoreEl.textContent = `คะแนนคุณ: ${playerScores.user}`;
        if (botScoreEl)
          botScoreEl.textContent = `คะแนนบอท: ${playerScores.bot}`;
      }

      // ฟังก์ชันใหม่: ซ่อนปุ่มชนะ
      function hideWinButtons() {
        if (tsumoBtn) tsumoBtn.style.display = 'none';
        if (ronBtn) ronBtn.style.display = 'none';
      }

      // ฟังก์ชันใหม่: แสดงปุ่มชนะ
      function showWinButtons() {
        if (tsumoBtn) tsumoBtn.style.display = 'inline-block';
        if (ronBtn) ronBtn.style.display = 'inline-block';
      }

      // Event Listeners สำหรับปุ่ม Tsumo/Ron (คุณต้องเพิ่มปุ่มใน HTML)
      if (tsumoBtn) {
        tsumoBtn.addEventListener('click', () => {
          if (currentTurn === 'user_action_check' && lastDiscarder === null) {
            // Tsumo จะเกิดขึ้นเมื่อผู้เล่นจั่วไพ่เองและชนะ
            declareWin('user', 'tsumo', userHand[userHand.length - 1]); // ไพ่ที่จั่วมาล่าสุด
          } else {
            updateGameMessage('ไม่สามารถ Tsumo ได้ในตอนนี้');
          }
        });
      }

      if (ronBtn) {
        ronBtn.addEventListener('click', () => {
          if (
            currentTurn === 'user_action_check' &&
            lastDiscarder !== null &&
            lastDiscardedTile !== null
          ) {
            // Ron จะเกิดขึ้นเมื่อผู้อื่นทิ้งไพ่
            declareWin('user', 'ron', lastDiscardedTile);
          } else {
            updateGameMessage('ไม่สามารถ Ron ได้ในตอนนี้');
          }
        });
      }

      // สร้างสำรับไพ่
      function createDeck() {
        for (const type in TILES) {
          TILES[type].forEach((tile) => {
            for (let i = 0; i < 4; i++) {
              // ไพ่แต่ละใบมี 4 ชุด
              deck.push(tile);
            }
          });
        }
      }

      // สับไพ่
      function shuffleDeck() {
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
      }

      // ตั้งค่า Dead Wall และจั่ว Dora Indicator
      function setupDeadWall() {
        // Dead Wall มี 14 ใบ (7 คู่)
        // 5 คู่แรกสำหรับ Kan (4) และ Dora Indicator (1)
        // อีก 2 คู่สำหรับ Ura-Dora (ถ้ามี)
        for (let i = 0; i < 14; i++) {
          deadWall.push(deck.pop());
        }
        // ไพ่แรกใน Dead Wall (ใบที่ 3 จากซ้าย) เป็น Dora Indicator
        doraIndicators.push(deadWall[4]); // สมมติว่าใบที่ 5 เป็น Dora indicator
        // console.log("Dora Indicator:", doraIndicators[0]); // สำหรับการ Debug
      }

      // แจกไพ่ (สำหรับเกมจริงจะมี 13 ใบ)
      function dealTiles() {
        for (let i = 0; i < 13; i++) {
          // แจก 13 ใบสำหรับแต่ละคน
          userHand.push(deck.pop());
          botHand.push(deck.pop());
        }
        sortHand(userHand); // จัดเรียงไพ่ในมือผู้เล่นเพื่อความสวยงาม
        sortHand(botHand); // จัดเรียงไพ่บอทด้วย (ภายใน)
      }

      // แสดงไพ่บนหน้าจอ
      function renderHands() {
        userTilesEl.innerHTML = '';
        userHand.forEach((tile) => {
          const tileEl = document.createElement('span');
          tileEl.classList.add('tile');
          tileEl.textContent = tile;
          // ผู้เล่นสามารถทิ้งไพ่ได้เมื่อเป็นตาของตัวเองและได้จั่วไพ่แล้ว
          // ถ้า Riichi แล้ว จะต้องบังคับทิ้งไพ่ที่ถูกต้อง
          if (currentTurn === 'user' && isUserDiscardPhase) {
            tileEl.addEventListener('click', () =>
              discardTile(tile, userHand, userTilesEl)
            );
          }
          userTilesEl.appendChild(tileEl);
        });

        // แสดงไพ่บอทเป็นตัวอักษร '?' เพื่อซ่อน
        botTilesEl.innerHTML = '';
        botHand.forEach(() => {
          const tileEl = document.createElement('span');
          tileEl.classList.add('tile');
          tileEl.textContent = '🀫'; // ใช้ emoji ไพ่นกกระจอกแทน
          botTilesEl.appendChild(tileEl);
        });

        discardedTilesEl.innerHTML = '';
        discardedTiles.forEach((tile) => {
          const tileEl = document.createElement('span');
          tileEl.classList.add('tile');
          tileEl.textContent = tile;
          discardedTilesEl.appendChild(tileEl);
        });

        renderOpenMelds(userOpenMelds, userOpenMeldsEl);
        renderOpenMelds(botOpenMelds, botOpenMeldsEl);
      }

      // แสดงมือเปิด (Chi/Pon/Kan)
      function renderOpenMelds(meldsArray, targetElement) {
        targetElement.innerHTML = '';
        if (meldsArray.length > 0) {
          const title = document.createElement('div');
          title.textContent = 'มือเปิด:';
          targetElement.appendChild(title);
        }
        meldsArray.forEach((meldObj) => {
          const meldGroupEl = document.createElement('div');
          meldGroupEl.classList.add('meld-group');
          meldObj.tiles.forEach((tile) => {
            // ใช้ meldObj.tiles
            const tileEl = document.createElement('span');
            tileEl.classList.add('tile');
            tileEl.textContent = tile;
            tileEl.style.cursor = 'default'; // ไม่ให้คลิกไพ่ในมือเปิด
            tileEl.style.transform = 'none'; // ไม่ให้ hover effect
            meldGroupEl.appendChild(tileEl);
          });
          targetElement.appendChild(meldGroupEl);
        });
      }

      // ล้างปุ่ม Chi/Pon/Kan
      function clearDynamicActions() {
        dynamicActionsEl.innerHTML = '';
      }

      // --- การเล่นเกม ---

      // ผู้เล่นจั่วไพ่
      drawTileBtn.addEventListener('click', () => {
        if (currentTurn !== 'user' || deck.length === 0 || isUserDiscardPhase) {
          updateGameMessage(
            'ไม่ใช่ตาของคุณ, ไพ่หมดแล้ว, หรือคุณยังไม่ได้ทิ้งไพ่!'
          );
          return;
        }
        if (isRiichiDeclared.user) {
          updateGameMessage(
            'คุณประกาศ Riichi แล้ว คุณไม่สามารถจั่วไพ่เพิ่มได้จนกว่าจะชนะหรือมี Kan'
          );
          return;
        }

        const newTile = deck.pop();
        userHand.push(newTile);
        sortHand(userHand);
        isUserDiscardPhase = true;
        renderHands();
        updateGameMessage(`คุณจั่วได้ไพ่ ${newTile} กรุณาทิ้งไพ่ 1 ใบ`);
        drawTileBtn.disabled = true;
        riichiBtn.disabled = !canRiichi(
          userHand,
          userOpenMelds,
          isRiichiDeclared.user
        );

        // ตรวจสอบ Tsumo ทันทีหลังจากจั่วไพ่
        const winResult = isWinningHand(userHand);
        if (winResult) {
          showWinButtons(); // แสดงปุ่ม Tsumo/Ron
          updateGameMessage(
            `คุณจั่วได้ไพ่ ${newTile}. คุณสามารถ Tsumo ได้! หรือทิ้งไพ่`
          );
          // ต้องรอให้ผู้เล่นกด Tsumo หรือทิ้งไพ่
        } else {
          hideWinButtons();
        }
      });

      // ผู้เล่นทิ้งไพ่
      function discardTile(tileToDiscard, hand, handEl) {
        // ต้องอยู่ในเฟสการทิ้งไพ่
        if (currentTurn !== 'user' || !isUserDiscardPhase) {
          updateGameMessage('กรุณาจั่วไพ่ก่อนทิ้ง!');
          return;
        }
        // ถ้าผู้เล่น Riichi แล้ว ต้องทิ้งไพ่ที่ทำให้ Tenpai
        // (ส่วนนี้จะซับซ้อนมาก และต้องใช้ Algorithm ตรวจสอบ Agari-gata)
        if (isRiichiDeclared.user) {
          // Placeholder: ในเกมจริงต้องตรวจสอบว่าการทิ้งไพ่ใบนี้ยังคงรักษา Tenpai หรือไม่
          // หากไม่รักษา Tenpai จะถือว่าผิดกฎ (Furikomi) และปรับแพ้ทันที
          // ในตัวอย่างนี้จะอนุญาตให้ทิ้งได้เลย
          updateGameMessage(
            'คุณอยู่ในสถานะ Riichi. ทิ้งไพ่ที่ทำให้คุณยัง Tenpai อยู่!'
          );
        }

        hideWinButtons(); // ซ่อนปุ่มชนะเมื่อทิ้งไพ่

        const index = hand.indexOf(tileToDiscard);
        if (index > -1) {
          hand.splice(index, 1);
          lastDiscardedTile = tileToDiscard; // เก็บไพ่ที่ถูกทิ้งล่าสุด
          lastDiscarder = 'user'; // ผู้เล่นทิ้งไพ่
          discardedTiles.push(tileToDiscard);
          isUserDiscardPhase = false; // สิ้นสุดเฟสการทิ้งไพ่ของผู้เล่น
          renderHands(); // อัปเดตมือผู้เล่นและกองทิ้ง
          updateGameMessage(`คุณทิ้งไพ่ ${tileToDiscard}`);

          // หลังจากผู้เล่นทิ้งไพ่ ให้บอทตรวจสอบ Chi/Pon/Kan
          clearDynamicActions(); // ล้างปุ่มของผู้เล่นก่อนส่งให้บอท
          currentTurn = 'bot_action_check'; // เปลี่ยนสถานะเป็นรอการตัดสินใจของบอท
          setTimeout(checkBotActions, 1000); // ให้บอทตรวจสอบ action
        } else {
          updateGameMessage('ไพ่ไม่อยู่ในมือคุณ');
        }
      }

      // ตรวจสอบ Action ของบอท (Chi/Pon/Kan)
      function checkBotActions() {
        clearDynamicActions();

        if (!lastDiscardedTile) {
          // ไม่มีไพ่ที่ทิ้งล่าสุด
          botTurn();
          return;
        }

        let canPerformAction = false;
        let canWin = false; // Flag for Ron

        // ตรวจสอบ Ron
        const winResult = isWinningHand([...userHand, lastDiscardedTile]); // ลองเพิ่มไพ่ที่ทิ้งมา
        if (winResult) {
          // ต้องตรวจสอบ Yaku ด้วย!
          const tempHandForYakuCheck = [...userHand, lastDiscardedTile];
          sortHand(tempHandForYakuCheck);
          const yakuFound = findYaku(
            winResult,
            tempHandForYakuCheck,
            userOpenMelds,
            lastDiscardedTile,
            'ron',
            {
              isRiichiDeclared: isRiichiDeclared.user,
              doraIndicators: doraIndicators,
              roundWind: roundWind,
              playerWind: playerWind.user,
            }
          );
          if (yakuFound.some((yaku) => yaku.name !== 'Dora' || yaku.han > 0)) {
            // ต้องมียากุที่ไม่ใช่ Dora อย่างน้อย 1 Han (หรือ Yakuman)
            canWin = true;
            showWinButtons(); // แสดงปุ่ม Ron
            updateGameMessage(
              `ไพ่ ${lastDiscardedTile} ที่บอททิ้งมา คุณสามารถ Ron ได้!`
            );
          }
        }

        // ... (โค้ดเดิมสำหรับ Chi/Pon/Kan) ...
        // ถ้ามี action ให้เลือก (Chi/Pon/Kan) หรือ Ron ให้แสดงปุ่ม Skip
        if (canPerformAction || canWin) {
          const skipBtn = document.createElement('button');
          skipBtn.textContent = 'ผ่าน';
          skipBtn.addEventListener('click', () => {
            clearDynamicActions();
            hideWinButtons(); // ซ่อนปุ่มชนะเมื่อกดผ่าน
            currentTurn = 'user';
            drawTileBtn.disabled = false;
            riichiBtn.disabled = !canRiichi(
              userHand,
              userOpenMelds,
              isRiichiDeclared.user
            );
            updateGameMessage('คุณเลือกผ่าน ถึงตาคุณจั่วไพ่');
          });
          dynamicActionsEl.appendChild(skipBtn);
        } else {
          // ถ้าไม่มี action ใดๆ และไม่ชนะ ให้จั่วไพ่
          currentTurn = 'user';
          drawTileBtn.disabled = false;
          riichiBtn.disabled = !canRiichi(
            userHand,
            userOpenMelds,
            isRiichiDeclared.user
          );
          updateGameMessage('ถึงตาคุณจั่วไพ่');
          hideWinButtons();
        }

        botTurn();
      }

      // บอทเล่น (จั่วและทิ้งไพ่)
      function botTurn() {
        if (deck.length === 0 && deadWall.length === 0) {
          // ตรวจสอบทั้ง deck และ deadWall
          updateGameMessage('ไพ่หมดแล้ว! เกมจบลง (Ryuukyoku)');
          drawTileBtn.disabled = true;
          currentTurn = 'game_over';
          return;
        }

        updateGameMessage('บอทกำลังจั่วไพ่...');
        setTimeout(() => {
          // บอทจั่วไพ่
          let newTile;
          if (deck.length > 0) {
            newTile = deck.pop();
          } else {
            // ในกรณีที่ไพ่ใน deck หมดแล้ว และ bot ต้อง Kan แต่ไม่มีไพ่ใน deadWall เหลือ (ไม่ควรเกิดขึ้น)
            updateGameMessage('ไพ่หมดแล้ว! เกมจบลง');
            currentTurn = 'game_over';
            return;
          }

          botHand.push(newTile);
          sortHand(botHand); // จัดเรียงไพ่บอท (ภายใน)

          // บอททิ้งไพ่: พยายามทิ้งไพ่ที่ "ไม่เข้าพวก" (มีจำนวนน้อยที่สุด)
          // หรืออาจจะทิ้งไพ่ที่ไม่ได้ใช้เป็น Yaku หรือ Tenpai
          const tileCounts = {};
          botHand.forEach((tile) => {
            tileCounts[tile] = (tileCounts[tile] || 0) + 1;
          });

          let tileToDiscard = botHand[0]; // ไพ่เริ่มต้นที่จะทิ้ง
          let minCount = 5; // มากกว่า 4 เพราะไพ่มี 4 ใบต่อชนิด

          // หาไพ่ที่มีจำนวนซ้ำน้อยที่สุด
          for (const tile of botHand) {
            if (tileCounts[tile] < minCount) {
              minCount = tileCounts[tile];
              tileToDiscard = tile;
            }
          }

          const indexToDiscard = botHand.indexOf(tileToDiscard);
          botHand.splice(indexToDiscard, 1);
          lastDiscardedTile = tileToDiscard;
          lastDiscarder = 'bot'; // บอททิ้งไพ่
          discardedTiles.push(tileToDiscard);

          renderHands(); // อัปเดตการแสดงผล
          updateGameMessage(`บอททิ้งไพ่ ${tileToDiscard}`);

          // ตรวจสอบ Tsumo ของบอท
          const botWinResult = isWinningHand(botHand);
          if (botWinResult) {
            // ต้องตรวจสอบ Yaku ด้วย!
            const yakuFound = findYaku(
              botWinResult,
              botHand,
              botOpenMelds,
              botHand[botHand.length - 1], // ไพ่ที่บอทจั่วมาล่าสุด
              'tsumo',
              {
                isRiichiDeclared: isRiichiDeclared.bot,
                doraIndicators: doraIndicators,
                roundWind: roundWind,
                playerWind: playerWind.bot,
              }
            );
            if (
              yakuFound.some((yaku) => yaku.name !== 'Dora' || yaku.han > 0)
            ) {
              declareWin('bot', 'tsumo', botHand[botHand.length - 1]);
              return; // บอทชนะ ไม่ต้องทิ้งไพ่
            }
          }

          // หลังจากบอททิ้งไพ่ ผู้เล่นตรวจสอบ Chi/Pon/Kan
          currentTurn = 'user_action_check'; // เปลี่ยนสถานะเป็นรอการตัดสินใจของผู้เล่น
          setTimeout(checkUserActions, 1000); // ให้ผู้เล่นตรวจสอบ action
        }, 1000);
      }

      /**
       * ฟังก์ชันใหม่: จัดการการประกาศชนะ (Tsumo/Ron)
       * @param {string} winner - 'user' หรือ 'bot'
       * @param {string} winType - 'tsumo' หรือ 'ron'
       * @param {string} winningTile - ไพ่ที่ทำให้ชนะ
       */
      function declareWin(winner, winType, winningTile) {
        let winningHand = [];
        let winningOpenMelds = [];
        let winnerIsDealerFlag = false;

        if (winner === 'user') {
          winningHand = [...userHand];
          winningOpenMelds = userOpenMelds;
          winnerIsDealerFlag = isDealer.user;
        } else {
          winningHand = [...botHand];
          winningOpenMelds = botOpenMelds;
          winnerIsDealerFlag = isDealer.bot;
        }

        // สำหรับ Ron, ไพ่ที่ชนะต้องถูกเพิ่มเข้าไปในมือชั่วคราวเพื่อตรวจสอบ Yaku
        if (winType === 'ron' && !winningHand.includes(winningTile)) {
          winningHand.push(winningTile);
          sortHand(winningHand);
        }

        const winResult = isWinningHand(winningHand);
        if (!winResult) {
          updateGameMessage(
            'เกิดข้อผิดพลาด: มือไม่ชนะ (ไม่มีรูปแบบ 4 กลุ่ม 1 คู่ หรือ Yaku พิเศษ)'
          );
          return;
        }

        const yakuFound = findYaku(
          winResult,
          winningHand,
          winningOpenMelds,
          winningTile,
          winType,
          {
            isRiichiDeclared:
              winner === 'user' ? isRiichiDeclared.user : isRiichiDeclared.bot,
            doraIndicators: doraIndicators,
            roundWind: roundWind,
            playerWind: winner === 'user' ? playerWind.user : playerWind.bot,
          }
        );

        if (yakuFound.length === 0) {
          updateGameMessage(
            `${
              winner === 'user' ? 'คุณ' : 'บอท'
            }ไม่มียากุ (Han) เพียงพอที่จะชนะ!`
          );
          // ในเกมจริงจะมี Chombo หรือแค่ไม่สามารถชนะได้
          // แต่สำหรับตอนนี้ ให้เป็นข้อความแจ้ง
          hideWinButtons(); // ซ่อนปุ่มชนะถ้าไม่มี Yaku
          // อาจจะให้เกมดำเนินต่อไป หรือเริ่มต้นใหม่ ขึ้นอยู่กับกฎ
          return;
        }

        const totalHan = yakuFound.reduce((sum, yaku) => sum + yaku.han, 0);
        const totalFu = calculateFu(
          winResult,
          winningOpenMelds,
          winningTile,
          winType,
          {
            roundWind: roundWind,
            playerWind: winner === 'user' ? playerWind.user : playerWind.bot,
          }
        );

        const scoreResult = calculateScore(
          totalHan,
          totalFu,
          winType,
          winnerIsDealerFlag
        );

        // อัปเดตคะแนน
        if (winner === 'user') {
          playerScores.user += scoreResult.totalScore;
          if (winType === 'ron') {
            playerScores.bot -= scoreResult.totalScore; // หักจากบอทที่ทิ้ง
          } else if (winType === 'tsumo') {
            // Tsumo: Dealer จ่าย 2 เท่า, Non-Dealer จ่าย 1 เท่า
            if (winnerIsDealerFlag) {
              // ผู้เล่นเป็น Dealer
              playerScores.bot -= scoreResult.otherPlayers; // bot จ่ายเท่ากัน
            } else {
              // ผู้เล่นไม่ใช่ Dealer
              playerScores.bot -= scoreResult.otherPlayers; // bot จ่ายตามปกติ (1x baseScore)
              // ต้องมีผู้เล่นคนที่ 3 จ่ายส่วน Dealer ด้วยในเกม 3/4 คน
            }
          }
        } else {
          // บอทชนะ
          playerScores.bot += scoreResult.totalScore;
          if (winType === 'ron') {
            playerScores.user -= scoreResult.totalScore; // หักจากผู้เล่นที่ทิ้ง
          } else if (winType === 'tsumo') {
            if (winnerIsDealerFlag) {
              // บอทเป็น Dealer
              playerScores.user -= scoreResult.otherPlayers; // ผู้เล่นจ่ายเท่ากัน
            } else {
              // บอทไม่ใช่ Dealer
              playerScores.user -= scoreResult.otherPlayers; // ผู้เล่นจ่ายตามปกติ
              // ต้องมีผู้เล่นคนที่ 3 จ่ายส่วน Dealer ด้วย
            }
          }
        }

        updateScoresDisplay(); // อัปเดตการแสดงผลคะแนน

        const yakuNames = yakuFound
          .map((y) => `${y.name} (${y.han} Han)`)
          .join(', ');
        updateGameMessage(
          `${winner === 'user' ? 'คุณ' : 'บอท'}ชนะแล้ว! ${
            winType === 'tsumo' ? 'Tsumo' : 'Ron'
          }! Yaku: ${yakuNames}. รวม ${totalHan} Han, ${totalFu} Fu. ได้รับคะแนน: ${
            scoreResult.totalScore
          }!`
        );

        drawTileBtn.disabled = true;
        riichiBtn.disabled = true;
        hideWinButtons();
        currentTurn = 'game_over'; // จบเกมหรือจบแค่รอบ (ต้องมีระบบรอบ)

        // TODO: เพิ่ม Logic สำหรับเริ่มรอบใหม่
        // เช่น: ปุ่ม "เริ่มรอบใหม่"
      }

      // ตรวจสอบ Action ของผู้เล่น (Chi/Pon/Kan)
      function checkUserActions() {
        clearDynamicActions(); // ล้างปุ่มเดิมออกก่อน

        if (!lastDiscardedTile) {
          // ไม่มีไพ่ที่ทิ้งล่าสุด (เช่น ผู้เล่นเพิ่งทำการ Pon/Kan และทิ้งไพ่ไปแล้ว)
          currentTurn = 'user';
          drawTileBtn.disabled = false;
          riichiBtn.disabled = !canRiichi(
            userHand,
            userOpenMelds,
            isRiichiDeclared.user
          );
          updateGameMessage('ถึงตาคุณจั่วไพ่');
          return;
        }

        let canPerformAction = false;

        // ตรวจสอบ Pon
        if (canPon(userHand, lastDiscardedTile)) {
          const ponBtn = document.createElement('button');
          ponBtn.textContent = 'Pon';
          ponBtn.addEventListener('click', () => {
            performPon(userHand, lastDiscardedTile, userOpenMelds);
            clearDynamicActions();
            currentTurn = 'user'; // ผู้เล่นจะทิ้งไพ่หลังจาก Pon
            isUserDiscardPhase = true; // ผู้เล่นต้องทิ้งไพ่
            updateGameMessage('คุณ Pon! กรุณาทิ้งไพ่ 1 ใบ');
            drawTileBtn.disabled = true; // ป้องกันการจั่วซ้ำ
            isRiichiDeclared.user = false; // ยกเลิก Riichi เพราะมือเปิดแล้ว
            riichiBtn.disabled = true; // ไม่สามารถ Riichi ได้หลังจากเปิดมือ
            renderHands(); // Render อีกครั้งเพื่อให้ไพ่ในมือคลิกได้
          });
          dynamicActionsEl.appendChild(ponBtn);
          canPerformAction = true;
        }

        // ตรวจสอบ Chi (ทำได้เฉพาะไพ่ที่ทิ้งจากผู้เล่น "ก่อนหน้า" ตามลำดับการเล่น)
        // ในเกมนี้มีแค่บอทกับผู้เล่น ดังนั้น lastDiscarder ต้องเป็น 'bot'
        if (lastDiscarder === 'bot') {
          const chiOptions = canChi(userHand, lastDiscardedTile);
          if (chiOptions.length > 0) {
            chiOptions.forEach((option) => {
              const chiBtn = document.createElement('button');
              chiBtn.textContent = `Chi (${option.join('')})`; // แสดงไพ่ที่ใช้ Chi
              chiBtn.addEventListener('click', () => {
                performChi(userHand, lastDiscardedTile, option, userOpenMelds);
                clearDynamicActions();
                currentTurn = 'user'; // ผู้เล่นจะทิ้งไพ่หลังจาก Chi
                isUserDiscardPhase = true; // ผู้เล่นต้องทิ้งไพ่
                updateGameMessage('คุณ Chi! กรุณาทิ้งไพ่ 1 ใบ');
                drawTileBtn.disabled = true; // ป้องกันการจั่วซ้ำ
                isRiichiDeclared.user = false; // ยกเลิก Riichi เพราะมือเปิดแล้ว
                riichiBtn.disabled = true; // ไม่สามารถ Riichi ได้หลังจากเปิดมือ
                renderHands(); // Render อีกครั้งเพื่อให้ไพ่ในมือคลิกได้
              });
              dynamicActionsEl.appendChild(chiBtn);
              canPerformAction = true;
            });
          }
        }

        // ตรวจสอบ Kan (คานเปิด: Minkan) จากไพ่ที่ทิ้ง
        if (canKan(userHand, lastDiscardedTile)) {
          const kanBtn = document.createElement('button');
          kanBtn.textContent = 'Kan (Minkan)';
          kanBtn.addEventListener('click', () => {
            performMinkan(userHand, lastDiscardedTile, userOpenMelds);
            clearDynamicActions();
            // ผู้เล่นจะได้จั่วไพ่เสริม (Rinshan Kaihou) และทิ้งไพ่ 1 ใบ
            const newTile = deadWall.shift(); // จั่วไพ่เสริมจาก Dead Wall
            if (!newTile) {
              updateGameMessage('ไม่สามารถจั่วไพ่เสริมได้ Dead Wall หมด!');
              // จัดการกรณีที่ Dead Wall หมด (เกมอาจจบลง)
              return;
            }
            userHand.push(newTile);
            sortHand(userHand);

            flipDora(); // พลิก Dora indicator เพิ่ม

            currentTurn = 'user'; // ผู้เล่นจะทิ้งไพ่หลังจาก Kan
            isUserDiscardPhase = true; // ผู้เล่นต้องทิ้งไพ่
            updateGameMessage(
              `คุณ Kan ไพ่ ${lastDiscardedTile}! คุณจั่วไพ่เสริม ${newTile} กรุณาทิ้งไพ่ 1 ใบ`
            );
            drawTileBtn.disabled = true; // ป้องกันการจั่วซ้ำ
            isRiichiDeclared.user = false; // ยกเลิก Riichi เพราะมือเปิดแล้ว
            riichiBtn.disabled = true; // ไม่สามารถ Riichi ได้หลังจากเปิดมือ
            renderHands(); // Render อีกครั้งเพื่อให้ไพ่ในมือคลิกได้
          });
          dynamicActionsEl.appendChild(kanBtn);
          canPerformAction = true;
        }

        // ตรวจสอบ Ankan (คานปิด) - ทำได้ในตาผู้เล่นเท่านั้น และไม่จำเป็นต้องมีไพ่ทิ้งล่าสุด
        // ผู้เล่นสามารถ Ankan ได้ตลอดหากมีไพ่ 4 ใบในมือ
        // และ Ankan ไม่นับเป็นการเปิดมือ ดังนั้นยัง Riichi ได้อยู่
        const ankanOptions = canAnkan(userHand);
        if (ankanOptions.length > 0 && !isUserDiscardPhase) {
          // ต้องไม่ใช่เฟสทิ้งไพ่
          ankanOptions.forEach((tile) => {
            const ankanBtn = document.createElement('button');
            ankanBtn.textContent = `Kan (Ankan ${tile})`;
            ankanBtn.addEventListener('click', () => {
              performAnkan(userHand, tile, userOpenMelds);
              clearDynamicActions();
              // ผู้เล่นจะได้จั่วไพ่เสริม (Rinshan Kaihou) และทิ้งไพ่ 1 ใบ
              const newTile = deadWall.shift(); // จั่วไพ่เสริมจาก Dead Wall
              if (!newTile) {
                updateGameMessage('ไม่สามารถจั่วไพ่เสริมได้ Dead Wall หมด!');
                return;
              }
              userHand.push(newTile);
              sortHand(userHand);
              flipDora(); // พลิก Dora indicator เพิ่ม

              currentTurn = 'user'; // ผู้เล่นจะทิ้งไพ่หลังจาก Kan
              isUserDiscardPhase = true; // ผู้เล่นต้องทิ้งไพ่
              updateGameMessage(
                `คุณ Ankan ไพ่ ${tile}! คุณจั่วไพ่เสริม ${newTile} กรุณาทิ้งไพ่ 1 ใบ`
              );
              drawTileBtn.disabled = true; // ป้องกันการจั่วซ้ำ
              // Riichi สถานะจะยังคงอยู่ ถ้าเคย Riichi แล้ว
              riichiBtn.disabled = !canRiichi(
                userHand,
                userOpenMelds,
                isRiichiDeclared.user
              ); // ยัง Riichi ได้หากยัง Tenpai และไม่มีมือเปิดอื่น
              renderHands();
            });
            dynamicActionsEl.appendChild(ankanBtn);
            canPerformAction = true;
          });
        }

        // ตรวจสอบ Chakan (คานเพิ่ม) - เพิ่มไพ่ใบที่ 4 ลงใน Pon ที่เปิดอยู่
        const chakanOptions = canChakan(userHand, userOpenMelds);
        if (chakanOptions.length > 0 && !isUserDiscardPhase) {
          chakanOptions.forEach((meldObj) => {
            const chakanBtn = document.createElement('button');
            chakanBtn.textContent = `Kan (Chakan ${meldObj.tiles[0]})`;
            chakanBtn.addEventListener('click', () => {
              performChakan(userHand, meldObj, userOpenMelds);
              clearDynamicActions();
              const newTile = deadWall.shift(); // จั่วไพ่เสริมจาก Dead Wall
              if (!newTile) {
                updateGameMessage('ไม่สามารถจั่วไพ่เสริมได้ Dead Wall หมด!');
                return;
              }
              userHand.push(newTile);
              sortHand(userHand);
              flipDora(); // พลิก Dora indicator เพิ่ม

              currentTurn = 'user';
              isUserDiscardPhase = true;
              updateGameMessage(
                `คุณ Chakan ไพ่ ${meldObj.tiles[0]}! คุณจั่วไพ่เสริม ${newTile} กรุณาทิ้งไพ่ 1 ใบ`
              );
              drawTileBtn.disabled = true;
              isRiichiDeclared.user = false; // Chakan ทำให้มือเปิดเช่นกัน แม้จะเคย Riichi มาก่อน
              riichiBtn.disabled = true;
              renderHands();
            });
            dynamicActionsEl.appendChild(chakanBtn);
            canPerformAction = true;
          });
        }

        // ถ้าไม่มี action ใดๆ ผู้เล่นก็จั่วไพ่ (สำหรับตาปกติ) หรือถ้ามีการกด "ผ่าน"
        if (!canPerformAction) {
          currentTurn = 'user';
          drawTileBtn.disabled = false;
          riichiBtn.disabled = !canRiichi(
            userHand,
            userOpenMelds,
            isRiichiDeclared.user
          );
          updateGameMessage('ถึงตาคุณจั่วไพ่');
        } else {
          // เพิ่มปุ่ม "ผ่าน" หรือ "Skip" ถ้ามีตัวเลือก Chi/Pon/Kan
          const skipBtn = document.createElement('button');
          skipBtn.textContent = 'ผ่าน';
          skipBtn.addEventListener('click', () => {
            clearDynamicActions();
            currentTurn = 'user';
            drawTileBtn.disabled = false;
            riichiBtn.disabled = !canRiichi(
              userHand,
              userOpenMelds,
              isRiichiDeclared.user
            );
            updateGameMessage('คุณเลือกผ่าน ถึงตาคุณจั่วไพ่');
          });
          dynamicActionsEl.appendChild(skipBtn);
        }
      }

      // ตรวจสอบว่าสามารถ Chi (กิน) ได้หรือไม่
      // ส่งคืน array ของไพ่ 2 ใบที่สามารถใช้ Chi ได้
      function canChi(playerHand, lastDiscarded) {
        const options = [];
        const discardType = getTileType(lastDiscarded);
        const discardValue = getTileValue(lastDiscarded);

        // Chi ทำได้เฉพาะกับไพ่ตัวเลข
        if (
          discardType &&
          (discardType === 'characters' ||
            discardType === 'dots' ||
            discardType === 'bamboos')
        ) {
          const potentialTiles = TILES[discardType];

          // สร้าง copy ของมือผู้เล่นเพื่อไม่ให้กระทบกับ original array
          const handCopy = [...playerHand];
          const handCounts = countTilesInHand(handCopy);

          // ตรวจสอบชุด (value-2, value-1, discarded) เช่น กิน 3 ด้วย 1,2
          if (discardValue >= 3) {
            const tile1 = potentialTiles[discardValue - 3];
            const tile2 = potentialTiles[discardValue - 2];
            if (handCounts[tile1] && handCounts[tile2]) {
              options.push([tile1, tile2]);
            }
          }
          // ตรวจสอบชุด (value-1, discarded, value+1) เช่น กิน 3 ด้วย 2,4
          if (discardValue >= 2 && discardValue <= 8) {
            const tile1 = potentialTiles[discardValue - 2];
            const tile2 = potentialTiles[discardValue];
            if (handCounts[tile1] && handCounts[tile2]) {
              options.push([tile1, tile2]);
            }
          }
          // ตรวจสอบชุด (discarded, value+1, value+2) เช่น กิน 3 ด้วย 4,5
          if (discardValue <= 7) {
            const tile1 = potentialTiles[discardValue];
            const tile2 = potentialTiles[discardValue + 1];
            if (handCounts[tile1] && handCounts[tile2]) {
              options.push([tile1, tile2]);
            }
          }
        }
        return options; // อาจจะมีหลายชุดที่ Chi ได้
      }

      // ดำเนินการ Chi
      function performChi(playerHand, discardedTile, chiTiles, openMeldsArray) {
        // ลบไพ่ 2 ใบที่ใช้ Chi ออกจากมือผู้เล่น
        chiTiles.forEach((tile) => {
          const index = playerHand.indexOf(tile);
          if (index > -1) {
            playerHand.splice(index, 1);
          }
        });
        // เพิ่มชุด Chi เข้าไปใน openMeldsArray
        const meldTiles = chiTiles
          .concat(discardedTile)
          .sort(
            (a, b) => ALL_TILES_ORDER.indexOf(a) - ALL_TILES_ORDER.indexOf(b)
          );
        openMeldsArray.push({ type: 'chi', tiles: meldTiles });
        sortHand(playerHand); // จัดเรียงไพ่ที่เหลือในมือ
        updateGameMessage(
          `คุณ Chi ไพ่ ${discardedTile} ด้วย ${chiTiles.join('')}`
        );
        lastDiscardedTile = null; // ไพ่ที่ทิ้งล่าสุดถูกใช้ไปแล้ว
      }

      // ตรวจสอบว่าสามารถ Pon (เรียกตอง) ได้หรือไม่
      function canPon(playerHand, lastDiscarded) {
        let count = 0;
        playerHand.forEach((tile) => {
          if (tile === lastDiscarded) {
            count++;
          }
        });
        return count >= 2;
      }

      // ดำเนินการ Pon
      function performPon(playerHand, discardedTile, openMeldsArray) {
        // ลบไพ่ 2 ใบที่ใช้ Pon ออกจากมือผู้เล่น
        let count = 0;
        for (let i = playerHand.length - 1; i >= 0; i--) {
          if (playerHand[i] === discardedTile && count < 2) {
            playerHand.splice(i, 1);
            count++;
          }
        }
        // เพิ่มชุด Pon เข้าไปใน openMeldsArray
        openMeldsArray.push({
          type: 'pon',
          tiles: [discardedTile, discardedTile, discardedTile],
        });
        sortHand(playerHand); // จัดเรียงไพ่ที่เหลือในมือ
        updateGameMessage(`คุณ Pon ไพ่ ${discardedTile}`);
        lastDiscardedTile = null; // ไพ่ที่ทิ้งล่าสุดถูกใช้ไปแล้ว
      }

      // ตรวจสอบว่าสามารถ Kan (คานเปิด: Minkan) ได้หรือไม่
      function canKan(playerHand, lastDiscarded) {
        let count = 0;
        playerHand.forEach((tile) => {
          if (tile === lastDiscarded) {
            count++;
          }
        });
        return count >= 3; // ต้องมีไพ่เดียวกันอีก 3 ใบในมือ
      }

      // ดำเนินการ Kan (คานเปิด: Minkan)
      function performMinkan(playerHand, discardedTile, openMeldsArray) {
        // ลบไพ่ 3 ใบที่ใช้ Kan ออกจากมือผู้เล่น
        let count = 0;
        for (let i = playerHand.length - 1; i >= 0; i--) {
          if (playerHand[i] === discardedTile && count < 3) {
            playerHand.splice(i, 1);
            count++;
          }
        }
        // เพิ่มชุด Kan เข้าไปใน openMeldsArray
        openMeldsArray.push({
          type: 'minkan',
          tiles: [discardedTile, discardedTile, discardedTile, discardedTile],
        });
        sortHand(playerHand); // จัดเรียงไพ่ที่เหลือในมือ
        updateGameMessage(`คุณ Minkan ไพ่ ${discardedTile}`);
        lastDiscardedTile = null; // ไพ่ที่ทิ้งล่าสุดถูกใช้ไปแล้ว
      }

      // ตรวจสอบ Ankan (คานปิด) - สามารถทำได้เมื่อมีไพ่ 4 ใบในมือ
      function canAnkan(playerHand) {
        const possibleAnkans = [];
        const counts = countTilesInHand(playerHand);
        for (const tile in counts) {
          if (counts[tile] === 4) {
            possibleAnkans.push(tile);
          }
        }
        return possibleAnkans; // คืนค่า array ของไพ่ที่สามารถ Ankan ได้
      }

      // ดำเนินการ Ankan (คานปิด)
      function performAnkan(playerHand, tileToKan, openMeldsArray) {
        // ลบไพ่ 4 ใบออกจากมือผู้เล่น
        let count = 0;
        for (let i = playerHand.length - 1; i >= 0; i--) {
          if (playerHand[i] === tileToKan && count < 4) {
            playerHand.splice(i, 1);
            count++;
          }
        }
        // เพิ่มชุด Ankan เข้าไปใน openMeldsArray (Ankan ถือเป็น meld แต่ไม่นับว่าเปิดมือ)
        openMeldsArray.push({
          type: 'ankan',
          tiles: [tileToKan, tileToKan, tileToKan, tileToKan],
        });
        sortHand(playerHand);
        updateGameMessage(`คุณ Ankan ไพ่ ${tileToKan}`);
      }

      // ตรวจสอบ Chakan (คานเพิ่ม) - เพิ่มไพ่ใบที่ 4 ลงใน Pon ที่เปิดอยู่แล้ว
      function canChakan(playerHand, openMeldsArray) {
        const possibleChakans = [];
        for (const meld of openMeldsArray) {
          if (meld.type === 'pon' && playerHand.includes(meld.tiles[0])) {
            // ถ้ามีไพ่ใบที่ 4 ในมือที่ตรงกับไพ่ใน Pon ที่เปิดอยู่
            possibleChakans.push(meld);
          }
        }
        return possibleChakans; // คืนค่า array ของ meld ที่สามารถ Chakan ได้
      }

      // ดำเนินการ Chakan (คานเพิ่ม)
      function performChakan(playerHand, ponMeld, openMeldsArray) {
        const tileToKan = ponMeld.tiles[0];
        const indexInHand = playerHand.indexOf(tileToKan);
        if (indexInHand > -1) {
          playerHand.splice(indexInHand, 1); // ลบไพ่ใบที่ 4 ออกจากมือ
          // อัปเดตประเภทของ meld จาก 'pon' เป็น 'chakan' และเพิ่มไพ่
          ponMeld.type = 'chakan';
          ponMeld.tiles.push(tileToKan);
          sortHand(playerHand);
          updateGameMessage(`คุณ Chakan ไพ่ ${tileToKan}`);
        }
      }

      // พลิก Dora indicator (จาก Dead Wall)
      function flipDora() {
        if (doraIndicators.length < 5 && deadWall.length > 0) {
          // สามารถพลิก Dora ได้สูงสุด 5 ใบ
          const newDora = deadWall[4 + doraIndicators.length]; // ใบถัดไปใน Dead Wall
          if (newDora) {
            doraIndicators.push(newDora);
            // console.log("New Dora Indicator:", newDora); // สำหรับ Debug
            updateGameMessage(`มีการพลิก Dora Indicator ใหม่: ${newDora}`);
          }
        }
      }

      // --- ฟังก์ชัน Riichi (ซับซ้อนมาก เขียนแยกต่างหาก) ---
     // ปรับปรุงฟังก์ชัน canRiichi
     function canRiichi(hand, openMelds, isRiichiAlreadyDeclared) {
        if (openMelds.length > 0) { // Riichi requires a closed hand
          return false;
        }
        if (isRiichiAlreadyDeclared) { // Can only Riichi once
          return false;
        }
        if (deck.length < 4) { // Not enough tiles left to Riichi (usually 4 tiles left)
          // Some rulesets allow Riichi with fewer than 4 tiles, but 4 is common.
          return false;
        }

        const { isTenpai: handIsTenpai } = isTenpai(hand, openMelds); // ใช้ isTenpai เพื่อตรวจสอบ
        return handIsTenpai;
      }

      // อัปเดตข้อความในเกม
      function updateGameMessage(message) {
        gameMessageEl.textContent = message;
      }

      // --- เริ่มเกมเมื่อโหลดหน้าเว็บ ---
      document.addEventListener('DOMContentLoaded', initializeGame);

      // Riichi button logic
      riichiBtn.addEventListener('click', () => {
        if (canRiichi(userHand, userOpenMelds, isRiichiDeclared.user)) {
          updateGameMessage('คุณประกาศ Riichi! คุณต้องทิ้งไพ่ 1 ใบ');
          isRiichiDeclared.user = true; // ตั้งค่าสถานะ Riichi
          riichiBtn.disabled = true;
          drawTileBtn.disabled = true; // ป้องกันการจั่วซ้ำ
          isUserDiscardPhase = true; // ผู้เล่นต้องทิ้งไพ่
          // Logic for Riichi, e.g., turn 90 degrees one discarded tile
          // จะต้องมีระบบว่าผู้เล่นต้องทิ้งไพ่ที่ถูกต้องตามกฎ Riichi
          renderHands(); // Render อีกครั้งเพื่อให้ไพ่ในมือคลิกได้เพื่อทิ้ง
        } else {
          updateGameMessage(
            'ยังประกาศ Riichi ไม่ได้ (ยังไม่เข้า Tenpai หรือมือเปิดแล้ว)'
          );
        }
      });

      // ฟังก์ชันสำหรับตรวจสอบ Tenpai และ Winning Hand (แนวคิด)
      // การ Implement ส่วนนี้ต้องใช้ Algorithm ที่ซับซ้อนและอยู่นอกเหนือขอบเขตของตัวอย่างนี้
      // นี่เป็นเพียงโครงสร้างให้เห็นภาพ

      function countTilesInHand(hand) {
        const counts = {};
        hand.forEach((tile) => {
          counts[tile] = (counts[tile] || 0) + 1;
        });
        return counts;
      }

      /**
       * ตรวจสอบว่าไพ่ที่เหลือสามารถจัดเป็นจำนวนกลุ่มที่ต้องการได้หรือไม่
       * (เป็นฟังก์ชัน Recursive Backtracking ที่ยังไม่ Optimized)
       *
       * @param {object} counts - Object ที่เก็บจำนวนไพ่แต่ละชนิด
       * @param {number} requiredMelds - จำนวนกลุ่มที่ต้องการสร้าง
       * @returns {boolean} true ถ้าสามารถจัดได้
       */
      function canFormMelds(counts, requiredMelds) {
        if (requiredMelds === 0) {
          // ถ้าจำนวนกลุ่มที่ต้องการเป็น 0 แสดงว่าสร้างครบแล้ว
          // และต้องไม่มีไพ่เหลือใน counts เลย
          return Object.values(counts).every((count) => count === 0);
        }

        // หาไพ่ใบแรกที่มีอยู่ (เพื่อเริ่มต้นการพิจารณา)
        const availableTiles = Object.keys(counts).filter(
          (tile) => counts[tile] > 0
        );
        if (availableTiles.length === 0) {
          // ไม่มีไพ่เหลือ แต่ยังต้องการกลุ่ม แสดงว่าสร้างไม่ได้
          return false;
        }

        // เรียงไพ่เพื่อให้การวนลูปเป็นระบบ (สำคัญสำหรับประสิทธิภาพของ Backtracking)
        availableTiles.sort(
          (a, b) => ALL_TILES_ORDER.indexOf(a) - ALL_TILES_ORDER.indexOf(b)
        );
        const firstTile = availableTiles[0];
        const firstTileType = getTileType(firstTile);
        const firstTileValue = getTileValue(firstTile);

        // 1. ลองสร้าง Pon (Triplet)
        if (counts[firstTile] >= 3) {
          counts[firstTile] -= 3;
          if (canFormMelds(counts, requiredMelds - 1)) return true;
          counts[firstTile] += 3; // backtrack
        }

        // 2. ลองสร้าง Chi (Sequence) - ทำได้เฉพาะไพ่ตัวเลขและไม่นับไพ่เกียรติยศ
        if (
          firstTileType &&
          (firstTileType === 'characters' ||
            firstTileType === 'dots' ||
            firstTileType === 'bamboos')
        ) {
          // ตรวจสอบว่าสามารถหาไพ่ที่ต่อเนื่องกัน (value+1, value+2) ได้หรือไม่
          if (firstTileValue !== null && firstTileValue <= 7) {
            // 7 คือค่าสูงสุดที่ Chi ได้ (7-8-9)
            const nextTile = TILES[firstTileType][firstTileValue]; // ไพ่ที่มีค่า +1
            const nextNextTile = TILES[firstTileType][firstTileValue + 1]; // ไพ่ที่มีค่า +2

            if (
              counts[firstTile] >= 1 &&
              counts[nextTile] >= 1 &&
              counts[nextNextTile] >= 1
            ) {
              counts[firstTile] -= 1;
              counts[nextTile] -= 1;
              counts[nextNextTile] -= 1;

              if (canFormMelds(counts, requiredMelds - 1)) return true;

              counts[firstTile] += 1; // backtrack
              counts[nextTile] += 1;
              counts[nextNextTile] += 1;
            }
          }
        }
        return false;
      }
// ฟังก์ชัน Helper: ตรวจสอบว่ามืออยู่ในสถานะ Tenpai หรือไม่ และคืนค่าไพ่ที่รอ
function isTenpai(hand, openMelds = []) {
        const potentialWinningTiles = new Set();
        const allTiles = Object.values(TILES).flat(); // Get all possible tiles

        // สร้างมือเสมือน 13 ใบที่รวม Open Melds
        let baseHand = [...hand];
        // Note: For isTenpai, we usually check a 13-tile hand (before drawing the last one)
        // or a 14-tile hand that's one tile away from completion.
        // For simplicity here, we assume 'hand' is the current 13-tile hand before drawing.
        // If 'hand' includes the drawn tile already (14 tiles), remove one temporarily.

        if (baseHand.length % 3 === 2) { // If it's a 14-tile hand (just drawn a tile)
          // Temporarily remove each tile to check if removing it leads to Tenpai
          for (let i = 0; i < baseHand.length; i++) {
            const tempHand = [...baseHand];
            tempHand.splice(i, 1); // Remove one tile
            for (const testTile of allTiles) {
              const testHandWithWinTile = [...tempHand, testTile];
              if (isWinningHand(testHandWithWinTile)) {
                potentialWinningTiles.add(testTile);
              }
            }
          }
        } else { // If it's a 13-tile hand (before drawing or after discarding)
          for (const testTile of allTiles) {
            const testHandWithWinTile = [...baseHand, testTile];
            if (isWinningHand(testHandWithWinTile)) {
              potentialWinningTiles.add(testTile);
            }
          }
        }


        if (potentialWinningTiles.size > 0) {
          return { isTenpai: true, waits: Array.from(potentialWinningTiles) };
        }
        return { isTenpai: false, waits: [] };
      }
  
      function findYaku(
        winningPattern,
        fullHand,
        openMelds,
        winningTile,
        winType,
        gameState
      ) {
        const yakuList = [];
        const closedHandTiles = [...fullHand]; // ทำสำเนาเพื่อไม่ให้กระทบมือจริง

        // ลบไพ่ที่อยู่ใน openMelds ออกจาก closedHandTiles เพื่อหามือปิด
        openMelds.forEach((meld) => {
          meld.tiles.forEach((tile) => {
            const index = closedHandTiles.indexOf(tile);
            if (index > -1) {
              closedHandTiles.splice(index, 1);
            }
          });
        });

        const isMenzen = openMelds.length === 0; // เป็นมือปิดหรือไม่

        // Yakuman (Chiitoitsu, Kokushi Musou) - นับ Han แยกไปแล้ว
        if (winningPattern.type === 'chiitoitsu') {
          yakuList.push({ name: 'Chiitoitsu', han: 2 });
          // Chiitoitsu มี Han ตายตัว
          return yakuList; // Chiitoitsu ไม่นับ Yaku อื่นๆ นอกจาก Dora/Ura-Dora
        } else if (winningPattern.type === 'kokushi_musou') {
          yakuList.push({ name: 'Kokushi Musou', han: 13 }); // Yakuman
          // Kokushi Musou เป็น Yakuman ไม่นับ Yaku อื่นๆ
          return yakuList;
        }

        // Yaku ที่ต้องเป็นมือปิด (Menzen)
        if (isMenzen) {
          // Yaku: Menzen Tsumo (Self-Draw with Closed Hand)
          if (winType === 'tsumo') {
            yakuList.push({ name: 'Menzen Tsumo', han: 1 });
          }

          // Yaku: Riichi (มีอยู่แล้ว)
          if (gameState.isRiichiDeclared) {
            yakuList.push({ name: 'Riichi', han: 1 });
            // TODO: Ippatsu (First turn after Riichi) - Requires tracking turns
            // if (isIppatsu) yakuList.push({ name: 'Ippatsu', han: 1 });
            // TODO: Double Riichi (Riichi ในตาแรก) - Requires tracking first turn
            // if (isDoubleRiichi) yakuList.push({ name: 'Double Riichi', han: 2 });
          }

          // Yaku: Pinfu (No Fu from Melds, Only Chi, Menzen Tsumo/Ron, Ryanmen Wait)
          // Pinfu ซับซ้อนมาก และมีเงื่อนไขเกี่ยวกับ Fu และการรอ
          // ต้องไม่มี Pon/Kan ในมือปิด และ pair ต้องเป็นไพ่ธรรมดาที่ไม่ให้ Fu
          // และการรอต้องเป็น Ryanmen (สองข้าง)
          let isPinfu = true;
          if (winningPattern.type === 'standard' && winType === 'tsumo') {
            // Pinfu Tsumo
            if (
              !winningPattern.details.melds.every((meld) => {
                const type = getTileType(meld[0]);
                const v0 = getTileValue(meld[0]);
                const v1 = getTileValue(meld[1]);
                const v2 = getTileValue(meld[2]);
                // ตรวจสอบว่าเป็น Chi (ลำดับ) หรือไม่
                return (
                  type &&
                  (type === 'characters' ||
                    type === 'dots' ||
                    type === 'bamboos') &&
                  v0 === v1 - 1 &&
                  v1 === v2 - 1
                );
              })
            ) {
              isPinfu = false;
            }

            const pairTile = winningPattern.details.pair;
            const isYakuhaiPair =
              isHonorTile(pairTile) ||
              pairTile === gameState.roundWind ||
              pairTile === gameState.playerWind;
            if (isYakuhaiPair) isPinfu = false;

            // TODO: ตรวจสอบ Ryanmen Wait (การรอ 2 ด้าน)
            // นี้เป็นส่วนที่ซับซ้อนมาก ต้องวิเคราะห์มือที่เหลือ 2 ใบและไพ่ที่ชนะ
            // สำหรับตอนนี้ อาจจะสมมติว่าเป็น Ryanmen หรือ Implement logic later
            const waitType = getWaitType(
              winningPattern.details.fullHand,
              winningPattern.details.pair,
              winningTile
            );
            if (waitType !== 'ryanmen') isPinfu = false;

            if (isPinfu) {
              yakuList.push({ name: 'Pinfu', han: 1 });
            }
          } else if (
            winningPattern.type === 'standard' &&
            winType === 'ron' &&
            isMenzen
          ) {
            // Pinfu Ron
            // Pinfu Ron มีเงื่อนไขคล้าย Pinfu Tsumo แต่ไม่ต้องนับ Menzen Tsumo
            // และ Fu = 30 แทน 20 (ถ้าไม่นับ Fu จาก melds/wait)
            // Logic คล้ายกันกับ Pinfu Tsumo
            let isPinfuRon = true;
            if (
              !winningPattern.details.melds.every((meld) => {
                const type = getTileType(meld[0]);
                const v0 = getTileValue(meld[0]);
                const v1 = getTileValue(meld[1]);
                const v2 = getTileValue(meld[2]);
                return (
                  type &&
                  (type === 'characters' ||
                    type === 'dots' ||
                    type === 'bamboos') &&
                  v0 === v1 - 1 &&
                  v1 === v2 - 1
                );
              })
            ) {
              isPinfuRon = false;
            }

            const pairTile = winningPattern.details.pair;
            const isYakuhaiPair =
              isHonorTile(pairTile) ||
              pairTile === gameState.roundWind ||
              pairTile === gameState.playerWind;
            if (isYakuhaiPair) isPinfuRon = false;

            const waitType = getWaitType(
              winningPattern.details.fullHand,
              winningPattern.details.pair,
              winningTile
            );
            if (waitType !== 'ryanmen') isPinfuRon = false;

            if (isPinfuRon) {
              yakuList.push({ name: 'Pinfu', han: 1 });
            }
          }

          // Yaku: Iipeikou (Pure Double Chii)
          if (winningPattern.type === 'standard') {
            const chiMelds = winningPattern.details.melds.filter((meld) => {
              const type = getTileType(meld[0]);
              const v0 = getTileValue(meld[0]);
              const v1 = getTileValue(meld[1]);
              const v2 = getTileValue(meld[2]);
              return (
                type &&
                (type === 'characters' ||
                  type === 'dots' ||
                  type === 'bamboos') &&
                v0 === v1 - 1 &&
                v1 === v2 - 1
              ); // Check if it's a sequence
            });

            // Check for two identical chi melds
            for (let i = 0; i < chiMelds.length; i++) {
              for (let j = i + 1; j < chiMelds.length; j++) {
                if (
                  chiMelds[i][0] === chiMelds[j][0] &&
                  chiMelds[i][1] === chiMelds[j][1] &&
                  chiMelds[i][2] === chiMelds[j][2]
                ) {
                  yakuList.push({ name: 'Iipeikou', han: 1 });
                  break;
                }
              }
              if (yakuList.some((y) => y.name === 'Iipeikou')) break;
            }
          }

          // Yaku: Sanankou (Three Closed Triplets)
          // ตรวจสอบว่ามี Pon ปิด 3 ชุด
          if (winningPattern.type === 'standard') {
            const closedPonCount = winningPattern.details.melds.filter(
              (meld) =>
                meld.length === 3 &&
                meld[0] === meld[1] &&
                !openMelds.some(
                  (om) => om.type === 'pon' && om.tiles[0] === meld[0]
                ) // ไม่นับ Pon ที่เปิด
            ).length;
            if (closedPonCount === 3) {
              yakuList.push({ name: 'Sanankou', han: 2 });
            }
          }
        } // End of isMenzen

        // Yaku ที่สามารถเปิดมือได้
        // Yaku: Tanyao (All Simples) - มีอยู่แล้ว
        let isTanyao = true;
        for (const tile of fullHand) {
          if (!isSimpleTile(tile)) {
            isTanyao = false;
            break;
          }
        }
        if (isTanyao) {
          yakuList.push({ name: 'Tanyao', han: 1 });
        }

        // Yaku: Yakuhai (Dragon Triplets, Seat Wind, Round Wind) - มีอยู่แล้ว
        const fullHandCounts = countTilesInHand(fullHand);
        if (fullHandCounts['🀄'] >= 3) yakuList.push({ name: 'Hatsu', han: 1 });
        if (fullHandCounts['🀅'] >= 3) yakuList.push({ name: 'Haku', han: 1 });
        if (fullHandCounts['🀆'] >= 3) yakuList.push({ name: 'Chun', han: 1 });
        if (fullHandCounts[gameState.playerWind] >= 3)
          yakuList.push({ name: 'Jihai', han: 1 });
        if (fullHandCounts[gameState.roundWind] >= 3) {
          if (gameState.playerWind !== gameState.roundWind) {
            // หลีกเลี่ยงการนับซ้ำถ้าเป็นลมเดียวกัน
            yakuList.push({ name: 'Ba-fu', han: 1 });
          } else {
            // ถ้าลมเดียวกัน จะนับเป็น Daburu-Ton/Nan ถ้าไม่ได้นับ Yaku อื่นไปแล้ว
            // For simplicity, just count one if it's the same wind.
            // Or handle Daburu-Ton/Nan separately if needed.
          }
        }

        // Yaku: Toitoi (All Triplets/Quads)
        // ทุกกลุ่มต้องเป็น Pon/Kan
        if (winningPattern.type === 'standard') {
          const allMeldsAreTriplets = winningPattern.details.melds.every(
            (meld) => meld.length === 3 && meld[0] === meld[1]
          );
          if (allMeldsAreTriplets) {
            yakuList.push({ name: 'Toitoi', han: 2 });
          }
        }

        // Yaku: Honitsu (Half Flush)
        // ต้องมีไพ่เพียงสองชนิด: ไพ่ตัวเลขหนึ่งชนิด และไพ่เกียรติยศ
        // ตรวจสอบเฉพาะ type ของไพ่
        const uniqueTypes = new Set();
        let hasHonorTiles = false;
        let hasNumberTiles = false;
        let numberTileSuit = null; // 'characters', 'dots', 'bamboos'

        for (const tile of fullHand) {
          const type = getTileType(tile);
          uniqueTypes.add(type);
          if (isHonorTile(tile)) {
            hasHonorTiles = true;
          } else if (
            type === 'characters' ||
            type === 'dots' ||
            type === 'bamboos'
          ) {
            hasNumberTiles = true;
            if (!numberTileSuit) {
              numberTileSuit = type;
            } else if (numberTileSuit !== type) {
              // มีไพ่ตัวเลขมากกว่า 1 ชนิด
              numberTileSuit = 'mixed';
              break;
            }
          }
        }

        if (
          hasHonorTiles &&
          hasNumberTiles &&
          numberTileSuit !== 'mixed' &&
          uniqueTypes.size === 2
        ) {
          yakuList.push({ name: 'Honitsu', han: isMenzen ? 3 : 2 });
        }

        // Yaku: Chinitsu (Full Flush)
        // ต้องเป็นไพ่สีเดียวล้วนๆ (Man/Pin/Sou) ไม่มีไพ่เกียรติยศ
        if (
          hasNumberTiles &&
          !hasHonorTiles &&
          numberTileSuit !== 'mixed' &&
          uniqueTypes.size === 1
        ) {
          yakuList.push({ name: 'Chinitsu', han: isMenzen ? 6 : 5 });
        }

        // Yaku: Dora (มีอยู่แล้ว)
        let doraCount = 0;
        const actualDoraTiles = gameState.doraIndicators.map(getDoraTile);
        for (const dora of actualDoraTiles) {
          fullHand.forEach((tile) => {
            if (tile === dora) {
              doraCount++;
            }
          });
        }
        if (doraCount > 0) {
          yakuList.push({ name: 'Dora', han: doraCount }); // Dora สามารถให้ Han หลาย Han ได้
        }

        // Rule: ต้องมียากุ (Han) อย่างน้อย 1 Han (ยกเว้น Tenhou/Chiihou/Renhou ซึ่งเป็น Yakuman เริ่มต้น)
        const totalHan = yakuList.reduce((sum, yaku) => sum + yaku.han, 0);
        if (totalHan === 0) {
          // หากไม่มี Yaku เลย (เช่น มีแต่ Dora หรือไม่มีอะไรเลย)
          // และไม่ใช่ Tenhou/Chiihou/Renhou (ซึ่งต้องตรวจสอบแยกต่างหาก)
          // ให้คืนค่าว่างเปล่า เพื่อระบุว่าไม่สามารถชนะได้
          return [];
        }

        return yakuList;
      }

      // Helper: ฟังก์ชันสำหรับหาประเภทการรอ (Wait Type)
      // นี้เป็นเพียงการประมาณการณ์อย่างง่าย และควรจะซับซ้อนกว่านี้มากในเกมจริง
      function getWaitType(fullHand, pairTile, winningTile) {
        // เพื่อความแม่นยำ ต้องลบ pair และ melds ออกก่อน
        // แล้วดูว่าไพ่ที่เหลืออีก 2 ใบ รออะไรได้บ้าง

        // simplified logic:
        const counts = countTilesInHand(fullHand);
        counts[pairTile] -= 2; // ลบไพ่คู่

        const tempHandWithoutPair = [];
        for (const tile in counts) {
          for (let i = 0; i < counts[tile]; i++) {
            tempHandWithoutPair.push(tile);
          }
        }
        sortHand(tempHandWithoutPair);

        // ตัวอย่างการตรวจสอบ wait แบบง่ายๆ (ต้องซับซ้อนกว่านี้มาก)
        // ถ้าไพ่ที่เหลือเป็น 2 ใบที่สามารถสร้าง Chi ได้ และ winningTile อยู่ตรงกลาง (Ryanmen)
        if (tempHandWithoutPair.length === 2) {
          const tile1 = tempHandWithoutPair[0];
          const tile2 = tempHandWithoutPair[1];
          const type1 = getTileType(tile1);
          const val1 = getTileValue(tile1);
          const type2 = getTileType(tile2);
          const val2 = getTileValue(tile2);

          if (type1 === type2) {
            // เช่น 🀇,🀉  รอ 🀈 (Kanchan)
            if (val2 - val1 === 2 && winningTile === TILES[type1][val1]) {
              return 'kanchan';
            }
            // เช่น 🀇,🀈  รอ 🀉 (Ryanmen) หรือ 🀉,🀊 รอ 🀇 (Ryanmen)
            if (val2 - val1 === 1) {
              if (winningTile === TILES[type1][val2] && val2 < 9)
                return 'ryanmen';
              if (winningTile === TILES[type1][val1 - 1] && val1 > 1)
                return 'ryanmen';
            }
          }
        }

        // ถ้า winningTile ตรงกับไพ่คู่ที่เหลือใบเดียว (Tanki)
        if (counts[winningTile] === 1) {
          // ตรวจสอบว่าไพ่ที่ชนะไปเพิ่มเป็นคู่
          return 'tanki';
        }
        // ถ้า Winning Tile ทำให้เกิด Pon
        if (
          winningPattern.details.melds.some(
            (meld) =>
              meld[0] === winningTile &&
              meld[1] === winningTile &&
              meld[2] === winningTile
          )
        ) {
          // อันนี้คือ Shanpon (รอคู่ เพื่อสร้าง Pon) - ซับซ้อนมาก
          // For simplicity, let's treat it as a special case if needed for Fu.
        }

        return 'other'; // Placeholder for other complex waits or default
      }

      function calculateFu(
        winningPattern,
        openMelds,
        winningTile,
        winType,
        gameState
      ) {
        let fu = 20; // Fu พื้นฐานสำหรับมือที่ชนะใดๆ

        // Yaku ที่ Fu = 0 (Pinfu) หรือ Yaku ที่ Fu ไม่คิดแบบปกติ (Chiitoitsu, Kokushi Musou)
        // ต้องตรวจสอบ Pinfu และ Menzen Tsumo
        const isMenzen = openMelds.length === 0;
        const hasPinfu = findYaku(
          winningPattern,
          winningPattern.details.fullHand,
          openMelds,
          winningTile,
          winType,
          gameState
        ).some((y) => y.name === 'Pinfu');

        if (winningPattern.type === 'chiitoitsu') {
          return 25; // Chiitoitsu มี 25 Fu เสมอ
        }
        if (winningPattern.type === 'kokushi_musou') {
          return 0; // Yakuman ไม่คิด Fu
        }

        // กรณี Pinfu
        if (hasPinfu) {
          if (winType === 'tsumo') return 20; // Pinfu Tsumo = 20 Fu
          else if (winType === 'ron') return 30; // Pinfu Ron = 30 Fu (เพราะต้องคิด Fu จาก Ron)
        }

        // Fu จากการชนะ (Tsumo vs Ron)
        if (winType === 'tsumo') {
          fu += 2; // Tsumo Fu (+2)
        }

        // Fu จาก Pair (Jantou)
        const pairTile = winningPattern.details.pair;
        const roundWind = gameState.roundWind;
        const playerWind = gameState.playerWind;

        // Fu for Yakuhai pair (Dragon, Round Wind, Seat Wind)
        if (TILES.dragons.includes(pairTile)) {
          fu += 2;
        }
        if (pairTile === roundWind) {
          fu += 2;
        }
        if (pairTile === playerWind) {
          fu += 2;
        }
        // Double wind pair (e.g., East wind where round is East and player is East)
        if (pairTile === roundWind && pairTile === playerWind) {
          fu += 2; // เพิ่มอีก 2 เป็น 4 Fu
        }

        // Fu จาก Melds (Sets)
        winningPattern.details.melds.forEach((meld) => {
          const tile = meld[0];
          const isTerminalOrHonor = isTerminalTile(tile) || isHonorTile(tile);
          const meldIsClosed = !openMelds.some(
            (om) => om.tiles.includes(tile) && om.type !== 'ankan'
          ); // Ankan ไม่นับเป็นเปิดมือ

          if (meld.length === 3 && meld[0] === meld[1]) {
            // Pon
            let ponFu = 2;
            if (isTerminalOrHonor) ponFu *= 2; // 4 Fu
            if (meldIsClosed) ponFu *= 2; // Closed: 4 Fu (Simple) / 8 Fu (Terminal/Honor)
            fu += ponFu;
          } else if (meld.length === 4 && meld[0] === meld[1]) {
            // Kan (Minkan/Ankan/Chakan)
            let kanFu = 8;
            if (isTerminalOrHonor) kanFu *= 2; // 16 Fu
            if (meldIsClosed) kanFu *= 2; // Closed: 16 Fu (Simple) / 32 Fu (Terminal/Honor)
            fu += kanFu;
          }
          // Chi (Sequence) ไม่ให้ Fu
        });

        // Fu จากการรอ (Wait)
        // ต้องพิจารณาประเภทการรอจาก winningTile
        const waitType = getWaitType(
          winningPattern.details.fullHand,
          winningPattern.details.pair,
          winningTile
        );
        if (
          waitType === 'penchan' ||
          waitType === 'kanchan' ||
          waitType === 'tanki'
        ) {
          fu += 2;
        }
        // Shanpon wait also gives 2 Fu, but detecting it is more complex.

        // ปัด Fu ขึ้นเป็นหลักสิบ (e.g., 22 Fu -> 30 Fu)
        return Math.ceil(fu / 10) * 10;
      }
    </script>
  </body>
</html>
