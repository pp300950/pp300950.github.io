<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡πÄ‡∏Å‡∏°‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡∏±‡∏Å‡∏à‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Responsive)</title>
    <style>
        /* --- CSS --- */

        /* Prevent scrolling and ensure full screen */
        html {
            height: 100%;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100%;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            background-color: #0d0d0d;
            color: #c0c0c0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top */
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 900px;
            text-align: center;
            padding: 10px;
            box-sizing: border-box;
        }
        h1 {
            color: #e0e0e0;
            text-shadow: 0 0 5px #ffcc00;
            font-size: 1.8em;
            margin: 5px 0;
        }
        p {
            font-size: 1em;
            margin: 5px 0 10px 0;
        }
        canvas {
            border: 2px solid #5a5a5a;
            background-color: #1a1a1a;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
            width: 100%; /* Fill the container width */
            height: auto; /* Maintain aspect ratio */
            max-width: 800px; /* Max size on desktop */
            display: block;
            margin: 0 auto;
        }
        .controls {
            margin-top: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 1em;
            background-color: #ffcc00;
            border: none;
            color: #1a1a1a;
            cursor: pointer;
            transition: background-color 0.3s;
            border-radius: 5px;
        }
        button:hover {
            background-color: #e0b800;
        }
        #status-message {
            margin-top: 10px;
            font-size: 1em;
            font-weight: bold;
            min-height: 40px;
        }
        
        /* --- New styles for Filtering Section --- */
        #filtering-section {
            display: none; /* Hidden by default */
            margin-top: 20px;
            padding: 15px;
            border: 2px solid #5a5a5a;
            background-color: #1a1a1a;
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
        }
        #captured-data-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #captured-data-list li {
            background-color: #2a2a2a;
            margin: 5px 0;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
            word-wrap: break-word;
        }
        #captured-data-list li:hover {
            background-color: #ff4444;
            color: #fff;
        }
        #captured-data-list li.eliminated {
            text-decoration: line-through;
            background-color: #444;
            color: #888;
            cursor: not-allowed;
        }
        #confirm-button {
            margin-top: 15px;
            background-color: #00ff00;
        }
        #confirm-button:hover {
            background-color: #00cc00;
        }


        .correct { color: #00ff00; }
        .incorrect { color: #ff4444; }
        .info { color: #33bbff; }

        /* Media Query for small screens (mobile) */
        @media (max-width: 768px) {
            h1 { font-size: 1.2em; }
            p { font-size: 0.8em; }
            button { font-size: 0.9em; padding: 8px 16px; }
            #status-message { font-size: 0.9em; min-height: 30px; }
            #filtering-section { padding: 10px; }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Tor Network Simulation: The Chase</h1>
        <p id="instruction-text">‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏™‡∏µ‡πÅ‡∏î‡∏á üî¥ 5 ‡∏à‡∏∏‡∏î ‡πÅ‡∏ï‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏µ‡∏¢‡∏á 1 ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏à‡∏£‡∏¥‡∏á!<br>‡∏î‡∏±‡∏Å‡∏à‡∏±‡∏ö‡∏à‡∏∏‡∏î‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏ß‡∏ö‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</p>
        <canvas id="torNetwork"></canvas>
        <div class="controls">
            <button id="startButton">‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏î‡∏±‡∏Å‡∏à‡∏±‡∏ö</button>
        </div>
        <div id="status-message"></div>

        <div id="filtering-section">
            <h2>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏î‡∏±‡∏Å‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ</h2>
            <p>‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÉ‡∏ô‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠‡∏ú‡∏π‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏á‡∏™‡∏±‡∏¢‡∏ï‡∏±‡∏ß‡∏à‡∏£‡∏¥‡∏á ‡∏Ñ‡∏±‡∏î‡∏Å‡∏£‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡πâ‡∏ô</p>
            <ul id="captured-data-list"></ul>
            <button id="confirm-button">‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ú‡∏π‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏á‡∏™‡∏±‡∏¢‡∏Ñ‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('torNetwork');
    const ctx = canvas.getContext('2d');
    const startButton = document.getElementById('startButton');
    const statusMessage = document.getElementById('status-message');
    const filteringSection = document.getElementById('filtering-section');
    const capturedDataList = document.getElementById('captured-data-list');
    const confirmButton = document.getElementById('confirm-button');
    const instructionText = document.getElementById('instruction-text');

    // Canvas size for scaling calculations
    const BASE_WIDTH = 800;
    const BASE_HEIGHT = 600;
    let scale = 1;

    const NUM_RED_PACKETS = 5; // Total red packets (1 real, 4 decoys)
    const NUM_WARM_DECOYS = 5;
    const NUM_PACKETS = NUM_RED_PACKETS + NUM_WARM_DECOYS;
    const MAX_HOPS = 8;
    const WARM_COLORS = ['#ffcc00', '#ffa500', '#ff7f50', '#ff6347'];

    let nodes = [];
    let packets = [];
    let capturedData = [];
    let isGameRunning = false;
    let animationFrameId;
    let redPacketsToCapture = NUM_RED_PACKETS;

    // Original node positions (will be scaled)
    const baseNodeLocations = [
        { id: 'A', x: 100, y: 100 }, { id: 'B', x: 300, y: 50 }, { id: 'C', x: 500, y: 50 }, { id: 'D', x: 700, y: 100 },
        { id: 'E', x: 150, y: 300 }, { id: 'F', x: 400, y: 300 }, { id: 'G', x: 650, y: 300 },
        { id: 'H', x: 100, y: 500 }, { id: 'I', x: 300, y: 550 }, { id: 'J', x: 500, y: 550 }, { id: 'K', x: 700, y: 500 }
    ];
    const connections = {
        'A': ['B', 'E', 'H'], 'B': ['A', 'C', 'F'], 'C': ['B', 'D', 'F'], 'D': ['C', 'G', 'K'],
        'E': ['A', 'F', 'H', 'I'], 'F': ['B', 'C', 'E', 'G', 'I', 'J'], 'G': ['D', 'F', 'K', 'J'],
        'H': ['A', 'E', 'I'], 'I': ['E', 'F', 'H', 'J'], 'J': ['F', 'G', 'I', 'K'], 'K': ['D', 'G', 'J']
    };
    
    // --- Encryption Simulation ---
    const REAL_SUSPECT_ID = 'arm56';
    const REAL_DATA = '192113';
    const PRIME_KEY_1 = 9973;
    const PRIME_KEY_2 = 113;

    // Simple character-based "encryption"
    function encryptData(text, key) {
        let encrypted = '';
        for (let i = 0; i < text.length; i++) {
            encrypted += String.fromCharCode(text.charCodeAt(i) + (key % 95));
        }
        return btoa(encrypted); // Use base64 to make it look more realistic
    }

    function generateRandomUsername() {
        const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < 6; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    // --- Resizing Functions ---
    function resizeCanvas() {
        const container = document.querySelector('.container');
        const maxWidth = 800;
        let width = container.clientWidth - 20;
        if (width > maxWidth) width = maxWidth;

        scale = width / BASE_WIDTH;
        
        canvas.width = width;
        canvas.height = BASE_HEIGHT * scale;

        initNodes();
        if (isGameRunning) {
            packets.forEach(packet => {
                const currentNode = nodes.find(n => n.id === packet.currentPath[packet.currentPath.length - 1]);
                if (currentNode) {
                    packet.x = currentNode.x;
                    packet.y = currentNode.y;
                }
            });
        }
        draw();
    }

    function initNodes() {
        nodes = baseNodeLocations.map(loc => ({
            ...loc,
            x: loc.x * scale,
            y: loc.y * scale,
            isClicked: false
        }));
    }

    // --- Drawing Functions ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const NODE_RADIUS = 15 * scale;
        const PACKET_RADIUS = 8 * scale;
        const FONT_SIZE = 16 * scale;

        // Draw connections
        ctx.strokeStyle = '#404040';
        ctx.lineWidth = 1 * scale;
        Object.entries(connections).forEach(([startId, neighbors]) => {
            const startNode = nodes.find(n => n.id === startId);
            neighbors.forEach(neighborId => {
                const endNode = nodes.find(n => n.id === neighborId);
                ctx.beginPath();
                ctx.moveTo(startNode.x, startNode.y);
                ctx.lineTo(endNode.x, endNode.y);
                ctx.stroke();
            });
        });

        // Draw nodes
        nodes.forEach(node => {
            ctx.fillStyle = node.isClicked ? '#00ff00' : '#ffcc00';
            ctx.beginPath();
            ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#1a1a1a';
            ctx.font = `${FONT_SIZE}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.id, node.x, node.y);
        });

        // Draw packets
        packets.forEach(packet => {
            ctx.fillStyle = packet.color;
            ctx.beginPath();
            ctx.arc(packet.x, packet.y, PACKET_RADIUS, 0, 2 * Math.PI);
            ctx.fill();
        });
    }

    // --- Game Logic ---
    function startGame() {
        if (isGameRunning) return;
        isGameRunning = true;
        redPacketsToCapture = NUM_RED_PACKETS;
        capturedData = [];

        // UI Reset
        startButton.disabled = true;
        canvas.style.display = 'block';
        filteringSection.style.display = 'none';
        statusMessage.textContent = `‡∏î‡∏±‡∏Å‡∏à‡∏±‡∏ö‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö ${redPacketsToCapture} ‡∏à‡∏∏‡∏î`;
        statusMessage.className = 'info';

        initNodes();
        packets = [];

        // Create packets (real suspect + decoys)
        for (let i = 0; i < NUM_PACKETS; i++) {
            const startNode = nodes[Math.floor(Math.random() * nodes.length)];
            const isRed = i < NUM_RED_PACKETS;
            const isRealSuspect = (i === 0); // The first red packet is the real one
            
            packets.push({
                x: startNode.x,
                y: startNode.y,
                speed: (2 * scale) + (Math.random() * 0.5 - 0.25),
                target: null,
                currentPath: [startNode.id],
                isRealSuspect: isRed && isRealSuspect,
                isRedDecoy: isRed && !isRealSuspect,
                color: isRed ? '#ff0000' : WARM_COLORS[Math.floor(Math.random() * WARM_COLORS.length)]
            });
        }
        
        // Shuffle packets so the real suspect isn't always first in the array
        packets.sort(() => Math.random() - 0.5);

        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animate();
    }

    function animate() {
        if (!isGameRunning) return;

        for (let i = packets.length - 1; i >= 0; i--) {
            const packet = packets[i];

            if (!packet.target) {
                // End of life for non-red packets
                if (packet.currentPath.length >= MAX_HOPS && !packet.isRedDecoy && !packet.isRealSuspect) {
                    packets.splice(i, 1);
                    continue;
                }
                
                const currentNodeId = packet.currentPath[packet.currentPath.length - 1];
                const nextNodeId = connections[currentNodeId][Math.floor(Math.random() * connections[currentNodeId].length)];
                packet.target = nodes.find(n => n.id === nextNodeId);
                packet.currentPath.push(packet.target.id);
            }

            const dx = packet.target.x - packet.x;
            const dy = packet.target.y - packet.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < packet.speed) {
                const reachedNode = packet.target;
                packet.x = reachedNode.x;
                packet.y = reachedNode.y;

                if (reachedNode.isClicked) {
                    handlePacketCapture(packet, i, reachedNode);
                    reachedNode.isClicked = false; // Reset trap
                }
                packet.target = null;
            } else {
                packet.x += (dx / distance) * packet.speed;
                packet.y += (dy / distance) * packet.speed;
            }
        }
        
        draw();
        animationFrameId = requestAnimationFrame(animate);
    }
    
    function handlePacketCapture(packet, index, node) {
        // If a red packet (real or decoy) is caught
        if (packet.isRealSuspect || packet.isRedDecoy) {
            redPacketsToCapture--;
            
            let capturedInfo;
            if (packet.isRealSuspect) {
                capturedInfo = {
                    id: REAL_SUSPECT_ID,
                    data: encryptData(REAL_DATA, PRIME_KEY_1 * PRIME_KEY_2),
                    isSuspect: true
                };
            } else {
                const randomUser = generateRandomUsername();
                capturedInfo = {
                    id: randomUser,
                    data: encryptData(`decoy_data_${Math.random()}`, Math.floor(Math.random() * 10000)),
                    isSuspect: false
                };
            }
            capturedData.push(capturedInfo);
            packets.splice(index, 1);

            statusMessage.textContent = `‡∏î‡∏±‡∏Å‡∏à‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏µ‡∏Å ${redPacketsToCapture} ‡∏à‡∏∏‡∏î`;
            statusMessage.className = 'info';

            // Check if all red packets have been captured
            if (redPacketsToCapture === 0) {
                startFilteringPhase();
            }

        } else { // If a warm decoy is caught
            statusMessage.textContent = `‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏ß‡∏á‡∏™‡∏µ‡πÇ‡∏ó‡∏ô‡∏£‡πâ‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏ô‡∏î ${node.id}!`;
            statusMessage.className = 'info';
            packets.splice(index, 1);
        }
    }
    
    function startFilteringPhase() {
        isGameRunning = false;
        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        canvas.style.display = 'none'; // Hide canvas
        filteringSection.style.display = 'block'; // Show filtering UI
        statusMessage.textContent = '‡∏£‡∏ß‡∏ö‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏Ñ‡∏±‡∏î‡∏Å‡∏£‡∏≠‡∏á';
        statusMessage.className = 'correct';

        // Shuffle and display captured data
        capturedData.sort(() => Math.random() - 0.5);
        capturedDataList.innerHTML = '';
        capturedData.forEach(item => {
            const li = document.createElement('li');
            li.textContent = `User: ${item.id} | Encrypted Data: ${item.data}`;
            li.dataset.id = item.id;
            li.addEventListener('click', () => {
                if (!li.classList.contains('eliminated')) {
                    li.classList.add('eliminated');
                }
            });
            capturedDataList.appendChild(li);
        });
    }

    function resetGame() {
        isGameRunning = false;
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        
        startButton.disabled = false;
        startButton.textContent = "‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà";
        packets = [];
        capturedData = [];
        
        canvas.style.display = 'block';
        filteringSection.style.display = 'none';
        
        initNodes(); // Reset node clicks
        draw();
    }


    // --- Event Listeners ---
    function handleInteraction(event) {
        if (!isGameRunning) return;
        event.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const touch = event.touches ? event.touches[0] : event;
        const mouseX = touch.clientX - rect.left;
        const mouseY = touch.clientY - rect.top;

        for (const node of nodes) {
            const distance = Math.sqrt(Math.pow(node.x - mouseX, 2) + Math.pow(node.y - mouseY, 2));
            if (distance < (15 * scale)) {
                nodes.forEach(n => n.isClicked = false); // Only one trap at a time
                node.isClicked = true;
                statusMessage.textContent = `‡∏ß‡∏≤‡∏á‡∏Å‡∏±‡∏ö‡∏î‡∏±‡∏Å‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏ô‡∏î: ${node.id}`;
                statusMessage.className = 'info';
                draw();
                break;
            }
        }
    }
    
    confirmButton.addEventListener('click', () => {
        const remainingItems = [];
        document.querySelectorAll('#captured-data-list li').forEach(li => {
            if (!li.classList.contains('eliminated')) {
                remainingItems.push(li.dataset.id);
            }
        });

        if (remainingItems.length !== 1) {
            alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Ñ‡∏±‡∏î‡∏Å‡∏£‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏ô‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÄ‡∏û‡∏µ‡∏¢‡∏á 1 ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô');
            return;
        }

        const finalSuspectId = remainingItems[0];
        if (finalSuspectId === REAL_SUSPECT_ID) {
            filteringSection.innerHTML = `
                <h2 class="correct">‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡∏ß‡∏ï‡∏ô‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á!</h2>
                <p>‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡∏±‡∏ß‡∏ú‡∏π‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏á‡∏™‡∏±‡∏¢‡∏ó‡∏µ‡πà‡πÅ‡∏ó‡πâ‡∏à‡∏£‡∏¥‡∏á: <strong>${REAL_SUSPECT_ID}</strong></p>
                <p>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡πÑ‡∏î‡πâ‡∏Ñ‡∏∑‡∏≠: <strong>${REAL_DATA}</strong></p>
                <button onclick="window.location.href='https://google.com'">‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ñ‡∏±‡∏î‡πÑ‡∏õ</button> 
            `;
            // Change 'https://google.com' to your desired next page URL
        } else {
            statusMessage.textContent = `‡∏Ñ‡∏±‡∏î‡∏Ñ‡∏ô‡∏ú‡∏¥‡∏î! ‡∏ú‡∏π‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏á‡∏™‡∏±‡∏¢‡∏ï‡∏±‡∏ß‡∏à‡∏£‡∏¥‡∏á‡∏Ñ‡∏∑‡∏≠ ${REAL_SUSPECT_ID} ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà ${finalSuspectId} ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à‡πÉ‡∏´‡∏°‡πà`;
            statusMessage.className = 'incorrect';
            resetGame();
        }
    });

    canvas.addEventListener('click', handleInteraction);
    canvas.addEventListener('touchstart', handleInteraction);
    
    startButton.addEventListener('click', startGame);
    window.addEventListener('resize', resizeCanvas);

    // --- Initial Setup ---
    resizeCanvas();
</script>

</body>
</html>