<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>‡πÄ‡∏Å‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏õ‡∏£‡∏∞‡∏à‡∏±‡∏ç‡∏ö‡∏≤‡∏ô</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Kanit:wght@400;700&display=swap');
    
    :root {
      --bg-image: url('https://www.transparenttextures.com/patterns/dark-wood.png');
      --table-bg: #3d3029;
      --field-bg: rgba(0, 0, 0, 0.2);
      --player-color: #4a90e2;
      --bot-color: #e24a4a;
      --mana-color: #8a2be2;
      --card-bg: #fdfaf6;
      --card-border: #a1887f;
      --text-light: #ececec;
      --text-dark: #333;
    }

    * { box-sizing: border-box; }

    body {
      font-family: 'Kanit', sans-serif;
      background-color: var(--table-bg);
      background-image: var(--bg-image);
      color: var(--text-light);
      margin: 0;
      padding: 0;
      user-select: none;
      display: flex;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
    }

    .main-container {
        display: flex;
        flex-grow: 1;
    }
    
    #game-table {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
    }

    /* --- Player & Opponent Areas --- */
    .player-area, .opponent-area {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      height: 180px;
    }

    .hero-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .hero-portrait {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 4px solid;
      margin-bottom: 5px;
      background-color: #555;
      font-size: 2.5em;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #player-hero .hero-portrait { border-color: var(--player-color); }
    #bot-hero .hero-portrait { border-color: var(--bot-color); }

    .hero-stats {
      display: flex;
      gap: 10px;
      font-size: 1.1em;
      font-weight: bold;
      background-color: rgba(0,0,0,0.4);
      padding: 5px 10px;
      border-radius: 8px;
    }

    .hand-area {
      flex-grow: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: -30px; /* Overlap cards */
      perspective: 1000px;
      min-width: 400px;
    }
    
    .deck-area .card-back{
        box-shadow: 0 0 10px 2px rgba(255, 255, 100, 0.5);
    }

    /* --- Battlefield --- */
    .battlefield {
      flex-grow: 1;
      background: var(--field-bg);
      border-radius: 10px;
      border: 2px solid #2c211c;
      margin: 0 20px;
      display: flex;
      flex-direction: column;
    }
    .board-row {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      padding: 10px;
    }
    #botBoard { border-bottom: 2px dashed rgba(255,255,255,0.2); }

    /* --- Card Styling --- */
    .card, .card-back {
      width: 100px;
      height: 130px;
      border: 2px solid var(--card-border);
      border-radius: 10px;
      background-color: var(--card-bg);
      color: var(--text-dark);
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 8px;
      text-align: center;
      position: relative;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .card-name { font-weight: bold; font-size: 0.9em; line-height: 1.1; }
    .card-cost {
      position: absolute; top: -5px; left: -5px;
      background: var(--mana-color); color: white;
      width: 28px; height: 28px;
      border-radius: 50%; display: flex; align-items: center; justify-content: center;
      font-weight: bold; border: 2px solid white;
    }
    .card-stats {
      display: flex; justify-content: space-around; align-items: center; font-weight: bold;
      padding: 0 2px; font-size: 0.9em;
    }
    .card-desc { font-size: 0.75em; }

    #player-hand .card { cursor: pointer; }
    #player-hand .card:hover { transform: translateY(-15px) scale(1.1); z-index: 100; }
    .card.unplayable { opacity: 0.7; cursor: not-allowed; filter: grayscale(80%); }
    .card.unplayable:hover { transform: none; }

    .card-back {
      background: #5a453a;
      border-color: #3e3027;
      background-image: radial-gradient(circle, #8d6e63 20%, transparent 20%), radial-gradient(circle, #8d6e63 20%, transparent 20%);
      background-size: 10px 10px;
      background-position: 0 0, 5px 5px;
    }
    .card-count {
        position: absolute; bottom: 5px; right: 5px;
        background: rgba(0,0,0,0.7); color: white;
        padding: 2px 6px; border-radius: 4px; font-size: 0.8em;
    }
    
    #bot-hand .card-back {
        margin: 0 -35px; /* Tighter stack for hand */
    }

    /* --- Sidebar --- */
    .sidebar {
      width: 280px;
      background: rgba(0,0,0,0.2);
      padding: 15px;
      display: flex;
      flex-direction: column;
      border-left: 2px solid #2c211c;
    }
    .sidebar h3 { margin-top: 0; }
    #log {
      flex-grow: 1;
      background: rgba(0,0,0,0.5);
      border-radius: 8px;
      padding: 10px;
      overflow-y: auto;
      font-size: 0.9em;
      line-height: 1.5;
    }
    #log div:first-child { color: #f1c40f; }
    .controls { margin-top: 15px; display: grid; gap: 10px; }
    button {
      cursor: pointer; padding: 12px; border: none; border-radius: 8px;
      font-family: 'Kanit', sans-serif; font-size: 1em; font-weight: bold;
      color: white; transition: all 0.2s ease;
    }
    #btnNew { background-color: #27ae60; }
    #btnEndTurn { background-color: var(--player-color); }
    #btnPassTurn { background-color: #f39c12; }
    #btnDrawCard { background-color: #8e44ad; }
    button:hover { filter: brightness(1.1); }
    button:disabled { background-color: #7f8c8d; cursor: not-allowed; }
    
    /* Animations */
    @keyframes card-enter {
        from { opacity: 0; transform: scale(0.5); }
        to { opacity: 1; transform: scale(1); }
    }
    .card-enter { animation: card-enter 0.3s ease-out; }

    @keyframes damage-flash {
        0%, 100% { filter: none; transform: scale(1); }
        50% { filter: brightness(1.5) drop-shadow(0 0 5px #ff0000); transform: scale(1.05); }
    }
    .damage-flash { animation: damage-flash 0.4s ease; }
    
    .damage-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 2em;
        font-weight: bold;
        color: #ff4757;
        text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
        pointer-events: none;
        z-index: 1000;
        animation: float-up 0.8s ease-out forwards;
    }

    @keyframes float-up {
        from {
            opacity: 1;
            transform: translate(-50%, -50%);
        }
        to {
            opacity: 0;
            transform: translate(-50%, -150%);
        }
    }

  </style>
</head>
<body>

<div class="main-container">
    <div id="game-table">
      <!-- Opponent Area -->
      <div class="opponent-area">
        <div id="bot-deck" class="deck-area"></div>
        <div id="bot-hand" class="hand-area"></div>
        <div id="bot-hero" class="hero-info"></div>
      </div>

      <!-- Battlefield -->
      <div class="battlefield">
        <div id="botBoard" class="board-row"></div>
        <div id="playerBoard" class="board-row"></div>
      </div>

      <!-- Player Area -->
      <div class="player-area">
        <div id="player-deck" class="deck-area"></div>
        <div id="player-hand" class="hand-area"></div>
        <div id="player-hero" class="hero-info"></div>
      </div>
    </div>

    <div class="sidebar">
      <h3>‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå</h3>
      <div id="log"></div>
      <div class="controls">
        <button id="btnDrawCard">‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î (3 ‡∏°‡∏≤‡∏ô‡∏≤)</button>
        <button id="btnEndTurn">‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô</button>
        <button id="btnPassTurn">‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô</button>
        <button id="btnNew">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà</button>
      </div>
    </div>
</div>

<script>
const BASE_CARDS = [
  // ‡∏¢‡∏π‡∏ô‡∏¥‡∏ï
  {name:"‡∏û‡∏•‡∏ó‡∏´‡∏≤‡∏£", type:"creature", cost:1, atk:1, hp:3},
  {name:"‡∏™‡πÑ‡∏•‡∏°‡πå", type:"creature", cost:1, atk:2, hp:2},
  {name:"‡∏≠‡∏±‡∏®‡∏ß‡∏¥‡∏ô", type:"creature", cost:2, atk:2, hp:4},
  {name:"‡∏ô‡∏±‡∏Å‡∏ò‡∏ô‡∏π", type:"creature", cost:2, atk:3, hp:2},
  {name:"‡∏°‡∏∑‡∏≠‡∏™‡∏±‡∏á‡∏´‡∏≤‡∏£", type:"creature", cost:3, atk:4, hp:2},
  {name:"‡∏Å‡∏≥‡πÅ‡∏û‡∏á‡∏´‡∏¥‡∏ô", type:"creature", cost:3, atk:0, hp:5, armor: 3, desc:"‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô"},
  {name:"‡πÇ‡∏Å‡πÄ‡∏•‡πá‡∏°", type:"creature", cost:4, atk:3, hp:6},
  {name:"‡∏¢‡∏±‡∏Å‡∏©‡πå‡πÉ‡∏´‡∏ç‡πà", cost:5, type:"creature", atk:5, hp:8},
  {name:"‡∏°‡∏±‡∏á‡∏Å‡∏£", cost:8, type:"creature", atk:8, hp:10},
  // ‡πÄ‡∏ß‡∏ó‡∏°‡∏ô‡∏ï‡∏£‡πå
  {name:"‡∏ú‡∏•‡∏∂‡∏Å‡∏°‡∏≤‡∏ô‡∏≤", type:"spell", effect:"temp_mana", power: 2, cost:0, desc:"‡∏£‡∏±‡∏ö‡∏°‡∏≤‡∏ô‡∏≤ 2 ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÉ‡∏ô‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ô‡∏µ‡πâ"},
  {name:"‡∏´‡∏¥‡∏ô‡∏°‡∏≤‡∏ô‡∏≤", type:"spell", effect:"perm_mana", power: 1, cost:4, desc:"‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏°‡∏≤‡∏ô‡∏≤‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ñ‡∏≤‡∏ß‡∏£ 1 ‡∏´‡∏ô‡πà‡∏ß‡∏¢"},
  {name:"‡∏´‡∏≠‡∏Å‡∏™‡∏≤‡∏¢‡∏ü‡πâ‡∏≤", type:"spell", effect:"direct_damage", power: 3, cost:2, desc:"‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ 3 ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏™‡∏∏‡πà‡∏°"},
  {name:"‡πÄ‡∏Å‡∏£‡∏≤‡∏∞‡∏´‡∏ô‡∏≤‡∏°", type:"spell", effect:"thornmail", power: 2, cost:3, desc:"‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏™‡∏∏‡πà‡∏°‡∏ù‡πà‡∏≤‡∏¢‡πÄ‡∏£‡∏≤‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ 2 ‡∏´‡∏ô‡πà‡∏ß‡∏¢"},
  {name:"‡∏ô‡∏±‡∏Å‡∏ö‡∏ß‡∏ä", type:"spell", effect:"heal", power: 5, cost:2, desc:"‡∏ü‡∏∑‡πâ‡∏ô‡∏ü‡∏π HP 5 ‡∏´‡∏ô‡πà‡∏ß‡∏¢"},
  {name:"‡πÇ‡∏•‡πà‡∏®‡∏±‡∏Å‡∏î‡∏¥‡πå‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå", type:"spell", effect:"armor", power: 5, cost:3, desc:"‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏£‡∏≤‡∏∞ 5 ‡∏´‡∏ô‡πà‡∏ß‡∏¢"},
  {name:"‡∏Ñ‡∏≥‡∏™‡∏≤‡∏õ‡πÄ‡∏ß‡∏•‡∏≤", type:"spell", effect:"skip_turn", cost:6, desc:"‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡∏Ç‡∏≠‡∏á‡∏®‡∏±‡∏ï‡∏£‡∏π"},
];

let game = null;

function newDeck(){
  let d=[];
  for(let i=0;i<3;i++) d = d.concat(JSON.parse(JSON.stringify(BASE_CARDS)));
  return shuffle(d);
}
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    let j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

document.getElementById("btnNew").onclick = ()=>{
  game={
    player:{id:'player', name:'‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô', hp:30, armor:0, mana:1, maxMana:1, deck:newDeck(), hand:[], board:[], turnCount: 10, isSkipped: false},
    bot:{id:'bot', name:'‡∏ö‡∏≠‡∏ó', hp:30, armor:0, mana:1, maxMana:1, deck:newDeck(), hand:[], board:[], turnCount: 10, isSkipped: false},
    turn: 0,
    log:[],
    isCombatting: false
  };
  
  document.getElementById('btnNew').style.display = 'none';
  ['btnEndTurn', 'btnPassTurn', 'btnDrawCard'].forEach(id => document.getElementById(id).style.display = 'block');

  log("‡πÄ‡∏Å‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß!");
  for(let i=0;i<4;i++) draw("player"); 
  for(let i=0;i<4;i++) draw("bot");
  render();
};

document.getElementById("btnEndTurn").onclick=()=>{
  if (game.turn % 2 !== 0 || game.isCombatting) return;
  log("‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô");
  game.player.passed = false;
  game.player.turnCount--;
  startCombat();
};

document.getElementById("btnPassTurn").onclick=()=>{
  if (game.turn % 2 !== 0 || game.isCombatting) return;
  log("‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡πÅ‡∏•‡∏∞‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏° 1 ‡πÉ‡∏ö");
  game.player.passed = true;
  game.player.turnCount--;
  draw('player');
  startCombat();
};

document.getElementById("btnDrawCard").onclick=()=>{
    if (game.turn % 2 !== 0 || game.isCombatting || game.player.mana < 3) return;
    log("‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏ä‡πâ 3 ‡∏°‡∏≤‡∏ô‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î");
    game.player.mana -= 3;
    draw('player');
    render();
}

function draw(side){
  if (!game) return;
  let s = game[side];
  if(s.deck.length === 0){ 
    dealDamage(s, 1);
    log(`Fatigue! ${s.name} ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ 1 ‡∏´‡∏ô‡πà‡∏ß‡∏¢`); 
    return;
  }
  let card = s.deck.pop();
  s.hand.push(card);
  if (side === 'player') log(`${s.name} ‡∏à‡∏±‡πà‡∏ß‡πÑ‡∏î‡πâ‡∏Å‡∏≤‡∏£‡πå‡∏î`);
}

function playCard(side, handIndex){
  if (game.isCombatting) return;
  let s = game[side];
  if(handIndex < 0 || handIndex >= s.hand.length) return;

  let card = s.hand[handIndex];
  if(card.cost > s.mana){ 
    if(side === 'player') log("‡∏°‡∏≤‡∏ô‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏≠!"); 
    return; 
  }

  s.mana -= card.cost;
  s.hand.splice(handIndex, 1);
  log(`${s.name} ‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î ${card.name}!`);

  switch(card.type) {
    case 'creature':
      let unit = JSON.parse(JSON.stringify(card));
      unit.uid = `${side}-${Math.random().toString(36).substr(2,5)}`;
      unit.maxHp = card.hp;
      unit.armor = card.armor || 0;
      s.board.push(unit);
      break;
    
    case 'spell':
      handleSpell(s, card);
      break;
  }
  render();
  checkWinner();
}

function handleSpell(caster, card) {
    const enemySide = caster.id === 'player' ? game.bot : game.player;
    switch(card.effect) {
        case 'heal':
            caster.hp = Math.min(30, caster.hp + card.power);
            log(`${caster.name} ‡∏ü‡∏∑‡πâ‡∏ô‡∏ü‡∏π‡∏û‡∏•‡∏±‡∏á‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï ${card.power} ‡∏´‡∏ô‡πà‡∏ß‡∏¢`);
            break;
        case 'armor':
            caster.armor += card.power;
            log(`${caster.name} ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏£‡∏≤‡∏∞ ${card.power} ‡∏´‡∏ô‡πà‡∏ß‡∏¢`);
            break;
        case 'temp_mana':
            caster.mana = Math.min(10, caster.mana + card.power);
            log(`${caster.name} ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏°‡∏≤‡∏ô‡∏≤‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß ${card.power} ‡∏´‡∏ô‡πà‡∏ß‡∏¢`);
            break;
        case 'perm_mana':
            caster.maxMana = Math.min(10, caster.maxMana + card.power);
            log(`${caster.name} ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏°‡∏≤‡∏ô‡∏≤‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ñ‡∏≤‡∏ß‡∏£ ${card.power} ‡∏´‡∏ô‡πà‡∏ß‡∏¢`);
            break;
        case 'direct_damage':
            if (enemySide.board.length > 0) {
                const target = randomChoice(enemySide.board);
                log(`${card.name} ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ ${card.power} ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÅ‡∏Å‡πà ${target.name}`);
                dealUnitDamage(target, card.power);
            } else log(`${card.name} ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢!`);
            break;
        case 'thornmail':
            if (caster.board.length > 0) {
                const target = randomChoice(caster.board);
                target.thorns = (target.thorns || 0) + card.power;
                log(`${target.name} ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ ${card.power} ‡∏´‡∏ô‡πà‡∏ß‡∏¢!`);
            } else log(`${card.name} ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡πÉ‡∏´‡πâ‡∏£‡πà‡∏≤‡∏¢‡πÉ‡∏™‡πà!`);
            break;
        case 'skip_turn':
            enemySide.isSkipped = true;
            log(`${enemySide.name} ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ!`);
            break;
    }
}

function showDamageIndicator(targetElement, amount) {
    if (!targetElement || amount <= 0) return;
    const indicator = document.createElement('div');
    indicator.className = 'damage-indicator';
    indicator.textContent = `-${amount}`;
    targetElement.appendChild(indicator);
    setTimeout(() => indicator.remove(), 800);
}

function dealUnitDamage(unit, amount) {
    let damageLeft = amount;
    const damageToArmor = Math.min(damageLeft, unit.armor || 0);
    if (damageToArmor > 0) {
        unit.armor -= damageToArmor;
        damageLeft -= damageToArmor;
    }
    if (damageLeft > 0) unit.hp -= damageLeft;

    const unitEl = document.getElementById(unit.uid);
    showDamageIndicator(unitEl, amount);
    if (unitEl) {
        unitEl.classList.add('damage-flash');
        setTimeout(() => unitEl.classList.remove('damage-flash'), 400);
    }
}


function dealDamage(target, amount) { // For heroes
    const damageDealtToArmor = Math.min(target.armor, amount);
    if (damageDealtToArmor > 0) target.armor -= damageDealtToArmor;
    
    const remainingDamage = amount - damageDealtToArmor;
    if (remainingDamage > 0) target.hp -= remainingDamage;
    
    const targetElement = document.getElementById(target.id);
    showDamageIndicator(targetElement, amount);
    
    if(targetElement) targetElement.classList.add('damage-flash');
    setTimeout(() => {
        if(targetElement) targetElement.classList.remove('damage-flash');
        render();
        checkWinner();
    }, 400);
}

async function dealBoardDamage(board, totalDamage) {
    const delay = ms => new Promise(res => setTimeout(res, ms));
    let damageLeft = totalDamage;

    for (const unit of board) {
        if (damageLeft <= 0) break;
        const damageToUnit = Math.min(damageLeft, (unit.armor || 0) + unit.hp);
        dealUnitDamage(unit, damageToUnit);
        damageLeft -= damageToUnit;
        await delay(200);
    }
    render();
}


async function startCombat() {
    game.isCombatting = true;
    render();

    const { player, bot } = game;
    const delay = ms => new Promise(res => setTimeout(res, ms));

    log("--- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ü‡∏™‡∏ï‡πà‡∏≠‡∏™‡∏π‡πâ ---");

    const playerAtk = player.board.reduce((sum, u) => sum + u.atk, 0);
    const botAtk = bot.board.reduce((sum, u) => sum + u.atk, 0);

    // Player attacks bot's board
    if (playerAtk > 0 && bot.board.length > 0) {
        log(`‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏£‡∏ß‡∏° ${playerAtk} ‡∏´‡∏ô‡πà‡∏ß‡∏¢!`);
        await dealBoardDamage(bot.board, playerAtk);
    }
    await delay(300);

    // Bot's thorns reflect
    const botThornsDamage = bot.board.filter(u => u.hp > 0 && u.thorns > 0).reduce((sum, u) => sum + u.thorns, 0);
    if (botThornsDamage > 0 && player.board.length > 0) {
        log(`‡πÄ‡∏Å‡∏£‡∏≤‡∏∞‡∏´‡∏ô‡∏≤‡∏°‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏ó‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ ${botThornsDamage} ‡∏´‡∏ô‡πà‡∏ß‡∏¢!`);
        await dealBoardDamage(player.board, botThornsDamage);
    }
    await delay(300);

    // Bot attacks player's board
    if (botAtk > 0 && player.board.length > 0) {
        log(`‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏ö‡∏≠‡∏ó‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏£‡∏ß‡∏° ${botAtk} ‡∏´‡∏ô‡πà‡∏ß‡∏¢!`);
        await dealBoardDamage(player.board, botAtk);
    }
    await delay(300);
    
    // Player's thorns reflect
    const playerThornsDamage = player.board.filter(u => u.hp > 0 && u.thorns > 0).reduce((sum, u) => sum + u.thorns, 0);
    if (playerThornsDamage > 0 && bot.board.length > 0) {
        log(`‡πÄ‡∏Å‡∏£‡∏≤‡∏∞‡∏´‡∏ô‡∏≤‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ ${playerThornsDamage} ‡∏´‡∏ô‡πà‡∏ß‡∏¢!`);
        await dealBoardDamage(bot.board, playerThornsDamage);
    }
    
    await delay(500);
    cleanupBoards();
    await delay(200);

    // Hero damage calculation
    let damageToBotHero = playerAtk;
    let damageToPlayerHero = botAtk;

    if (player.passed && damageToPlayerHero > 0) {
        damageToPlayerHero = Math.ceil(damageToPlayerHero / 2);
        log("‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß!");
    }
    if (bot.passed && damageToBotHero > 0) {
        damageToBotHero = Math.ceil(damageToBotHero / 2);
        log("‡∏ö‡∏≠‡∏ó‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß!");
    }

    if (damageToBotHero > 0) dealDamage(bot, damageToBotHero);
    if (damageToPlayerHero > 0) dealDamage(player, damageToPlayerHero);

    await delay(500);
    log("--- ‡∏à‡∏ö‡πÄ‡∏ü‡∏™‡∏ï‡πà‡∏≠‡∏™‡∏π‡πâ ---");
    
    game.isCombatting = false;
    if(game.turn !== -1) nextTurn();
}


function cleanupBoards(){
  game.player.board = game.player.board.filter(u=>u.hp > 0);
  game.bot.board = game.bot.board.filter(u=>u.hp > 0);
  render();
}

function nextTurn(){
  game.turn++;
  const isPlayerTurn = game.turn % 2 === 0;
  const currentSide = isPlayerTurn ? game.player : game.bot;

  if (currentSide.isSkipped) {
      log(`${currentSide.name} ‡∏ñ‡∏π‡∏Å‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô!`);
      currentSide.isSkipped = false;
      render();
      setTimeout(nextTurn, 1000);
      return;
  }

  currentSide.maxMana = Math.min(10, currentSide.maxMana + 1);
  currentSide.mana = currentSide.maxMana;
  draw(isPlayerTurn ? 'player' : 'bot');
  log(`--- ‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏Ç‡∏≠‡∏á ${currentSide.name} (‡∏°‡∏≤‡∏ô‡∏≤: ${currentSide.mana}/${currentSide.maxMana}) ---`);
  
  if (!isPlayerTurn) {
    setTimeout(botTurn, 1500);
  }
  render();
}

function botTurn(){
  const { bot, player } = game;

  // Healing strategy
  const healCardInfo = bot.hand.map((c, i) => ({card: c, index: i})).find(x => x.card.effect === 'heal' && x.card.cost <= bot.mana);
  if (healCardInfo && bot.hp <= (30 - healCardInfo.card.power)) {
      playCard('bot', healCardInfo.index);
      setTimeout(botTurn, 1000);
      return;
  }

  // Pass Turn strategy
  const canPlayCreature = bot.hand.some(c => c.type === 'creature' && c.cost <= bot.mana);
  if (!canPlayCreature && player.board.length > 0 && bot.turnCount > 0) {
      log("‡∏ö‡∏≠‡∏ó‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô");
      bot.passed = true;
      bot.turnCount--;
      draw('bot');
      startCombat();
      return;
  }

  // All-in strategy
  if (bot.hp <= 10 && player.board.length > 0) {
      const affordableCreatures = bot.hand.map((c, i) => ({card: c, index: i})).filter(x => x.card.type === 'creature' && x.card.cost <= bot.mana);
      if (affordableCreatures.length > 0) {
          log("‡∏ö‡∏≠‡∏ó‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡πÇ‡∏´‡∏°‡∏î‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÄ‡∏ï‡πá‡∏°‡∏Å‡∏≥‡∏•‡∏±‡∏á!");
          playCard('bot', affordableCreatures[0].index);
          setTimeout(botTurn, 1000);
          return;
      }
  }
  
  // Standard play strategy
  let playable = bot.hand.map((c, i) => ({card: c, index: i})).filter(x => x.card.cost <= bot.mana).sort((a,b) => b.card.cost - a.card.cost);
  
  if (playable.length > 0) {
      playCard("bot", playable[0].index);
      setTimeout(botTurn, 1000);
  } else {
      log("‡∏ö‡∏≠‡∏ó‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô");
      bot.passed = false;
      if (bot.turnCount > 0) bot.turnCount--;
      startCombat();
  }
}


function randomChoice(arr){ return arr[Math.floor(Math.random() * arr.length)]; }

function checkWinner(){
  if (game.turn === -1) return;
  let gameOver = false;
  let winner = null;

  if(game.player.hp <= 0) winner = game.bot.name;
  if(game.bot.hp <= 0) winner = game.player.name;
  
  if (game.player.turnCount <= 0 && game.bot.turnCount <= 0 && !winner) {
      if (game.player.hp > game.bot.hp) winner = game.player.name;
      else if (game.bot.hp > game.player.hp) winner = game.bot.name;
      else winner = "‡πÄ‡∏™‡∏°‡∏≠";
  }

  if (winner) {
      if (winner === "‡πÄ‡∏™‡∏°‡∏≠") log("‡πÄ‡∏Å‡∏°‡∏à‡∏ö‡∏•‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏ú‡∏•‡πÄ‡∏™‡∏°‡∏≠!");
      else if (winner === game.player.name) log("‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏î‡πâ‡∏ß‡∏¢, ‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏ô‡∏∞!");
      else log("‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏û‡πâ‡πÅ‡∏•‡πâ‡∏ß!");
      
      setTimeout(() => alert(winner === "‡πÄ‡∏™‡∏°‡∏≠" ? "‡πÄ‡∏™‡∏°‡∏≠!" : `${winner} ‡πÄ‡∏õ‡πá‡∏ô‡∏ù‡πà‡∏≤‡∏¢‡∏ä‡∏ô‡∏∞!`), 100);
      game.turn = -1;
      gameOver = true;
  }

  if (gameOver) {
      document.getElementById('btnNew').style.display = 'block';
      ['btnEndTurn', 'btnPassTurn', 'btnDrawCard'].forEach(id => document.getElementById(id).style.display = 'none');
  }
}

// --- RENDER FUNCTIONS ---
function render(){
  if (!game) return;
  const isPlayerTurn = game.turn % 2 === 0;
  document.getElementById('btnEndTurn').disabled = !isPlayerTurn || game.isCombatting || game.player.turnCount <= 0;
  document.getElementById('btnPassTurn').disabled = !isPlayerTurn || game.isCombatting || game.player.turnCount <= 0;
  document.getElementById('btnDrawCard').disabled = !isPlayerTurn || game.isCombatting || game.player.mana < 3;
  renderHero('player', 'üßë‚ÄçüöÄ');
  renderHero('bot', 'ü§ñ');
  renderHand('player');
  renderHand('bot');
  renderDeck('player');
  renderDeck('bot');
  renderBoard();
  renderLog();
}

function renderHero(side, icon) {
    const s = game[side];
    const el = document.getElementById(`${side}-hero`);
    el.innerHTML = `
        <div id="${s.id}" class="hero-portrait">${icon}</div>
        <div class="hero-stats">
            <span>‚ù§Ô∏è ${s.hp}</span>
            <span>üõ°Ô∏è ${s.armor}</span>
            <span>üíß ${s.mana}/${s.maxMana}</span>
            <span>‚è≥ ${s.turnCount}</span>
        </div>`;
}

function renderHand(side) {
    const s = game[side];
    const handEl = document.getElementById(`${side}-hand`);
    handEl.innerHTML = '';
    
    if (side === 'player') {
        s.hand.forEach((c, idx) => {
            const div = document.createElement("div");
            div.className = "card";
            div.innerHTML = getCardHTML(c);
            
            if (s.mana >= c.cost && game.turn % 2 === 0 && !game.isCombatting) {
                div.onclick = () => playCard("player", idx);
            } else {
                div.classList.add("unplayable");
            }
            handEl.appendChild(div);
        });
    } else {
        for (let i = 0; i < s.hand.length; i++) {
            const div = document.createElement("div");
            div.className = "card-back";
            handEl.appendChild(div);
        }
    }
}

function renderDeck(side) {
    const s = game[side];
    const deckEl = document.getElementById(`${side}-deck`);
    if (s.deck.length > 0) {
        deckEl.innerHTML = `<div class="card-back"><div class="card-count">${s.deck.length}</div></div>`;
    } else {
        deckEl.innerHTML = '';
    }
}

function renderBoard() {
    ['player', 'bot'].forEach(side => {
        const boardEl = document.getElementById(`${side}Board`);
        boardEl.innerHTML = '';
        game[side].board.forEach(u => {
            const d = document.createElement("div");
            d.id = u.uid;
            d.className = "card";
            d.innerHTML = getCardHTML(u);
            boardEl.appendChild(d);
        });
    });
}

function getCardHTML(c) {
    let content = `<div class="card-cost">${c.cost}</div>
                      <div class="card-name">${c.name}</div>`;
                      
    if (c.type === 'creature') {
        const hpDisplay = c.maxHp ? `${c.hp}/${c.maxHp}` : c.hp;
        let statsHTML = ``;
        if (c.thorns) statsHTML += `<span>üåµ ${c.thorns}</span>`
        statsHTML += `<span>‚öîÔ∏è ${c.atk}</span>`;
        if (c.armor > 0) statsHTML += `<span>üõ°Ô∏è ${c.armor}</span>`;
        statsHTML += `<span>‚ù§Ô∏è ${hpDisplay}</span>`;
        
        content += `<div class="card-stats">${statsHTML}</div>`;
        if (c.desc) content += `<div class="card-desc">${c.desc}</div>`;

    } else if (c.type === 'spell') {
      content += `<div class="card-desc">${c.desc}</div>`;
    }
    return content;
}

function renderLog(){
  const lg = document.getElementById("log"); 
  lg.innerHTML = "";
  if (game && game.log) {
    game.log.slice().reverse().forEach(l => {
        const d = document.createElement("div"); 
        d.innerText = `> ${l}`; 
        lg.appendChild(d);
    });
  }
  lg.scrollTop = 0;
}

function log(msg){ 
    if(game) {
        game.log.push(msg); 
        renderLog();
    }
}

document.addEventListener('DOMContentLoaded', () => {
    log("‡∏Å‡∏î '‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πà‡∏ô");
    ['btnEndTurn', 'btnPassTurn', 'btnDrawCard'].forEach(id => document.getElementById(id).style.display = 'none');
    renderLog();
});

</script>
</body>
</html>

