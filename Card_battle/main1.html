<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>เกมการ์ดประจัญบาน</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Kanit:wght@400;700&display=swap');
    
    :root {
      --bg-image: url('https://www.transparenttextures.com/patterns/dark-wood.png');
      --table-bg: #3d3029;
      --field-bg: rgba(0, 0, 0, 0.2);
      --player-color: #4a90e2;
      --bot-color: #e24a4a;
      --mana-color: #8a2be2;
      --card-bg: #fdfaf6;
      --card-border: #a1887f;
      --text-light: #ececec;
      --text-dark: #333;
    }

    * { box-sizing: border-box; }

    body {
      font-family: 'Kanit', sans-serif;
      background-color: var(--table-bg);
      background-image: var(--bg-image);
      color: var(--text-light);
      margin: 0;
      padding: 0;
      user-select: none;
      display: flex;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
    }

    .main-container {
        display: flex;
        flex-grow: 1;
    }
    
    #game-table {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
    }

    /* --- Player & Opponent Areas --- */
    .player-area, .opponent-area {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      height: 180px;
    }

    .hero-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .hero-portrait {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 4px solid;
      margin-bottom: 5px;
      background-color: #555;
      font-size: 2.5em;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #player-hero .hero-portrait { border-color: var(--player-color); }
    #bot-hero .hero-portrait { border-color: var(--bot-color); }

    .hero-stats {
      display: flex;
      gap: 10px;
      font-size: 1.1em;
      font-weight: bold;
      background-color: rgba(0,0,0,0.4);
      padding: 5px 10px;
      border-radius: 8px;
    }

    .hand-area {
      flex-grow: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: -30px; /* Overlap cards */
      perspective: 1000px;
      min-width: 400px;
    }
    
    .deck-area .card-back{
        box-shadow: 0 0 10px 2px rgba(255, 255, 100, 0.5);
    }

    /* --- Battlefield --- */
    .battlefield {
      flex-grow: 1;
      background: var(--field-bg);
      border-radius: 10px;
      border: 2px solid #2c211c;
      margin: 0 20px;
      display: flex;
      flex-direction: column;
    }
    .board-row {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      padding: 10px;
    }
    #botBoard { border-bottom: 2px dashed rgba(255,255,255,0.2); }

    /* --- Card Styling --- */
    .card, .card-back {
      width: 100px;
      height: 130px;
      border: 2px solid var(--card-border);
      border-radius: 10px;
      background-color: var(--card-bg);
      color: var(--text-dark);
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 8px;
      text-align: center;
      position: relative;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .card-name { font-weight: bold; font-size: 0.9em; line-height: 1.1; }
    .card-cost {
      position: absolute; top: -5px; left: -5px;
      background: var(--mana-color); color: white;
      width: 28px; height: 28px;
      border-radius: 50%; display: flex; align-items: center; justify-content: center;
      font-weight: bold; border: 2px solid white;
    }
    .card-stats {
      display: flex; justify-content: space-around; align-items: center; font-weight: bold;
      padding: 0 2px; font-size: 0.9em;
    }
    .card-desc { font-size: 0.75em; }

    #player-hand .card { cursor: pointer; }
    #player-hand .card:hover { transform: translateY(-15px) scale(1.1); z-index: 100; }
    .card.unplayable { opacity: 0.7; cursor: not-allowed; filter: grayscale(80%); }
    .card.unplayable:hover { transform: none; }

    .card-back {
      background: #5a453a;
      border-color: #3e3027;
      background-image: radial-gradient(circle, #8d6e63 20%, transparent 20%), radial-gradient(circle, #8d6e63 20%, transparent 20%);
      background-size: 10px 10px;
      background-position: 0 0, 5px 5px;
    }
    .card-count {
        position: absolute; bottom: 5px; right: 5px;
        background: rgba(0,0,0,0.7); color: white;
        padding: 2px 6px; border-radius: 4px; font-size: 0.8em;
    }
    
    #bot-hand .card-back {
        margin: 0 -35px; /* Tighter stack for hand */
    }

    /* --- Sidebar --- */
    .sidebar {
      width: 280px;
      background: rgba(0,0,0,0.2);
      padding: 15px;
      display: flex;
      flex-direction: column;
      border-left: 2px solid #2c211c;
    }
    .sidebar h3 { margin-top: 0; }
    #log {
      flex-grow: 1;
      background: rgba(0,0,0,0.5);
      border-radius: 8px;
      padding: 10px;
      overflow-y: auto;
      font-size: 0.9em;
      line-height: 1.5;
    }
    #log div:first-child { color: #f1c40f; }
    .controls { margin-top: 15px; display: grid; gap: 10px; }
    button {
      cursor: pointer; padding: 12px; border: none; border-radius: 8px;
      font-family: 'Kanit', sans-serif; font-size: 1em; font-weight: bold;
      color: white; transition: all 0.2s ease;
    }
    #btnNew { background-color: #27ae60; }
    #btnEndTurn { background-color: var(--player-color); }
    #btnPassTurn { background-color: #f39c12; }
    #btnDrawCard { background-color: #8e44ad; }
    button:hover { filter: brightness(1.1); }
    button:disabled { background-color: #7f8c8d; cursor: not-allowed; }
    
    /* Animations */
    @keyframes card-enter {
        from { opacity: 0; transform: scale(0.5); }
        to { opacity: 1; transform: scale(1); }
    }
    .card-enter { animation: card-enter 0.3s ease-out; }

    @keyframes damage-flash {
        0%, 100% { filter: none; transform: scale(1); }
        50% { filter: brightness(1.5) drop-shadow(0 0 5px #ff0000); transform: scale(1.05); }
    }
    .damage-flash { animation: damage-flash 0.4s ease; }
    
    .damage-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 2em;
        font-weight: bold;
        color: #ff4757;
        text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
        pointer-events: none;
        z-index: 1000;
        animation: float-up 0.8s ease-out forwards;
    }

    @keyframes float-up {
        from {
            opacity: 1;
            transform: translate(-50%, -50%);
        }
        to {
            opacity: 0;
            transform: translate(-50%, -150%);
        }
    }

  </style>
</head>
<body>

<div class="main-container">
    <div id="game-table">
      <!-- Opponent Area -->
      <div class="opponent-area">
        <div id="bot-deck" class="deck-area"></div>
        <div id="bot-hand" class="hand-area"></div>
        <div id="bot-hero" class="hero-info"></div>
      </div>

      <!-- Battlefield -->
      <div class="battlefield">
        <div id="botBoard" class="board-row"></div>
        <div id="playerBoard" class="board-row"></div>
      </div>

      <!-- Player Area -->
      <div class="player-area">
        <div id="player-deck" class="deck-area"></div>
        <div id="player-hand" class="hand-area"></div>
        <div id="player-hero" class="hero-info"></div>
      </div>
    </div>

    <div class="sidebar">
      <h3>บันทึกเหตุการณ์</h3>
      <div id="log"></div>
      <div class="controls">
        <button id="btnDrawCard">จั่วการ์ด (3 มานา)</button>
        <button id="btnEndTurn">จบเทิร์น</button>
        <button id="btnPassTurn">ผ่านเทิร์น</button>
        <button id="btnNew">เริ่มเกมใหม่</button>
      </div>
    </div>
</div>

<script>
const BASE_CARDS = [
  // ยูนิต
  {name:"พลทหาร", type:"creature", cost:1, atk:1, hp:3},
  {name:"สไลม์", type:"creature", cost:1, atk:2, hp:2},
  {name:"อัศวิน", type:"creature", cost:2, atk:2, hp:4},
  {name:"นักธนู", type:"creature", cost:2, atk:3, hp:2},
  {name:"มือสังหาร", type:"creature", cost:3, atk:4, hp:2},
  {name:"กำแพงหิน", type:"creature", cost:3, atk:0, hp:5, armor: 3, desc:"ยูนิตป้องกัน"},
  {name:"โกเล็ม", type:"creature", cost:4, atk:3, hp:6},
  {name:"ยักษ์ใหญ่", cost:5, type:"creature", atk:5, hp:8},
  {name:"มังกร", cost:8, type:"creature", atk:8, hp:10},
  // เวทมนตร์
  {name:"ผลึกมานา", type:"spell", effect:"temp_mana", power: 2, cost:0, desc:"รับมานา 2 หน่วยในเทิร์นนี้"},
  {name:"หินมานา", type:"spell", effect:"perm_mana", power: 1, cost:4, desc:"เพิ่มมานาสูงสุดถาวร 1 หน่วย"},
  {name:"หอกสายฟ้า", type:"spell", effect:"direct_damage", power: 3, cost:2, desc:"สร้างความเสียหาย 3 หน่วยให้ยูนิตสุ่ม"},
  {name:"เกราะหนาม", type:"spell", effect:"thornmail", power: 2, cost:3, desc:"ยูนิตสุ่มฝ่ายเรารับผลสะท้อนความเสียหาย 2 หน่วย"},
  {name:"นักบวช", type:"spell", effect:"heal", power: 5, cost:2, desc:"ฟื้นฟู HP 5 หน่วย"},
  {name:"โล่ศักดิ์สิทธิ์", type:"spell", effect:"armor", power: 5, cost:3, desc:"ได้รับเกราะ 5 หน่วย"},
  {name:"คำสาปเวลา", type:"spell", effect:"skip_turn", cost:6, desc:"ข้ามเทิร์นถัดไปของศัตรู"},
];

let game = null;

function newDeck(){
  let d=[];
  for(let i=0;i<3;i++) d = d.concat(JSON.parse(JSON.stringify(BASE_CARDS)));
  return shuffle(d);
}
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    let j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

document.getElementById("btnNew").onclick = ()=>{
  game={
    player:{id:'player', name:'ผู้เล่น', hp:30, armor:0, mana:1, maxMana:1, deck:newDeck(), hand:[], board:[], turnCount: 10, isSkipped: false},
    bot:{id:'bot', name:'บอท', hp:30, armor:0, mana:1, maxMana:1, deck:newDeck(), hand:[], board:[], turnCount: 10, isSkipped: false},
    turn: 0,
    log:[],
    isCombatting: false
  };
  
  document.getElementById('btnNew').style.display = 'none';
  ['btnEndTurn', 'btnPassTurn', 'btnDrawCard'].forEach(id => document.getElementById(id).style.display = 'block');

  log("เกมเริ่มต้นแล้ว!");
  for(let i=0;i<4;i++) draw("player"); 
  for(let i=0;i<4;i++) draw("bot");
  render();
};

document.getElementById("btnEndTurn").onclick=()=>{
  if (game.turn % 2 !== 0 || game.isCombatting) return;
  log("ผู้เล่นจบเทิร์น");
  game.player.passed = false;
  game.player.turnCount--;
  startCombat();
};

document.getElementById("btnPassTurn").onclick=()=>{
  if (game.turn % 2 !== 0 || game.isCombatting) return;
  log("ผู้เล่นผ่านเทิร์นและจั่วการ์ดเพิ่ม 1 ใบ");
  game.player.passed = true;
  game.player.turnCount--;
  draw('player');
  startCombat();
};

document.getElementById("btnDrawCard").onclick=()=>{
    if (game.turn % 2 !== 0 || game.isCombatting || game.player.mana < 3) return;
    log("ผู้เล่นใช้ 3 มานาเพื่อจั่วการ์ด");
    game.player.mana -= 3;
    draw('player');
    render();
}

function draw(side){
  if (!game) return;
  let s = game[side];
  if(s.deck.length === 0){ 
    dealDamage(s, 1);
    log(`Fatigue! ${s.name} ได้รับความเสียหาย 1 หน่วย`); 
    return;
  }
  let card = s.deck.pop();
  s.hand.push(card);
  if (side === 'player') log(`${s.name} จั่วได้การ์ด`);
}

function playCard(side, handIndex){
  if (game.isCombatting) return;
  let s = game[side];
  if(handIndex < 0 || handIndex >= s.hand.length) return;

  let card = s.hand[handIndex];
  if(card.cost > s.mana){ 
    if(side === 'player') log("มานาไม่พอ!"); 
    return; 
  }

  s.mana -= card.cost;
  s.hand.splice(handIndex, 1);
  log(`${s.name} เล่นการ์ด ${card.name}!`);

  switch(card.type) {
    case 'creature':
      let unit = JSON.parse(JSON.stringify(card));
      unit.uid = `${side}-${Math.random().toString(36).substr(2,5)}`;
      unit.maxHp = card.hp;
      unit.armor = card.armor || 0;
      s.board.push(unit);
      break;
    
    case 'spell':
      handleSpell(s, card);
      break;
  }
  render();
  checkWinner();
}

function handleSpell(caster, card) {
    const enemySide = caster.id === 'player' ? game.bot : game.player;
    switch(card.effect) {
        case 'heal':
            caster.hp = Math.min(30, caster.hp + card.power);
            log(`${caster.name} ฟื้นฟูพลังชีวิต ${card.power} หน่วย`);
            break;
        case 'armor':
            caster.armor += card.power;
            log(`${caster.name} ได้รับเกราะ ${card.power} หน่วย`);
            break;
        case 'temp_mana':
            caster.mana = Math.min(10, caster.mana + card.power);
            log(`${caster.name} ได้รับมานาชั่วคราว ${card.power} หน่วย`);
            break;
        case 'perm_mana':
            caster.maxMana = Math.min(10, caster.maxMana + card.power);
            log(`${caster.name} เพิ่มมานาสูงสุดถาวร ${card.power} หน่วย`);
            break;
        case 'direct_damage':
            if (enemySide.board.length > 0) {
                const target = randomChoice(enemySide.board);
                log(`${card.name} สร้างความเสียหาย ${card.power} หน่วยแก่ ${target.name}`);
                dealUnitDamage(target, card.power);
            } else log(`${card.name} ไม่มีเป้าหมาย!`);
            break;
        case 'thornmail':
            if (caster.board.length > 0) {
                const target = randomChoice(caster.board);
                target.thorns = (target.thorns || 0) + card.power;
                log(`${target.name} ได้รับผลสะท้อนความเสียหาย ${card.power} หน่วย!`);
            } else log(`${card.name} ไม่มียูนิตให้ร่ายใส่!`);
            break;
        case 'skip_turn':
            enemySide.isSkipped = true;
            log(`${enemySide.name} จะถูกข้ามเทิร์นถัดไป!`);
            break;
    }
}

function showDamageIndicator(targetElement, amount) {
    if (!targetElement || amount <= 0) return;
    const indicator = document.createElement('div');
    indicator.className = 'damage-indicator';
    indicator.textContent = `-${amount}`;
    targetElement.appendChild(indicator);
    setTimeout(() => indicator.remove(), 800);
}

function dealUnitDamage(unit, amount) {
    let damageLeft = amount;
    const damageToArmor = Math.min(damageLeft, unit.armor || 0);
    if (damageToArmor > 0) {
        unit.armor -= damageToArmor;
        damageLeft -= damageToArmor;
    }
    if (damageLeft > 0) unit.hp -= damageLeft;

    const unitEl = document.getElementById(unit.uid);
    showDamageIndicator(unitEl, amount);
    if (unitEl) {
        unitEl.classList.add('damage-flash');
        setTimeout(() => unitEl.classList.remove('damage-flash'), 400);
    }
}


function dealDamage(target, amount) { // For heroes
    const damageDealtToArmor = Math.min(target.armor, amount);
    if (damageDealtToArmor > 0) target.armor -= damageDealtToArmor;
    
    const remainingDamage = amount - damageDealtToArmor;
    if (remainingDamage > 0) target.hp -= remainingDamage;
    
    const targetElement = document.getElementById(target.id);
    showDamageIndicator(targetElement, amount);
    
    if(targetElement) targetElement.classList.add('damage-flash');
    setTimeout(() => {
        if(targetElement) targetElement.classList.remove('damage-flash');
        render();
        checkWinner();
    }, 400);
}

async function dealBoardDamage(board, totalDamage) {
    const delay = ms => new Promise(res => setTimeout(res, ms));
    let damageLeft = totalDamage;

    for (const unit of board) {
        if (damageLeft <= 0) break;
        const damageToUnit = Math.min(damageLeft, (unit.armor || 0) + unit.hp);
        dealUnitDamage(unit, damageToUnit);
        damageLeft -= damageToUnit;
        await delay(200);
    }
    render();
}


async function startCombat() {
    game.isCombatting = true;
    render();

    const { player, bot } = game;
    const delay = ms => new Promise(res => setTimeout(res, ms));

    log("--- เริ่มเฟสต่อสู้ ---");

    const playerAtk = player.board.reduce((sum, u) => sum + u.atk, 0);
    const botAtk = bot.board.reduce((sum, u) => sum + u.atk, 0);

    // Player attacks bot's board
    if (playerAtk > 0 && bot.board.length > 0) {
        log(`ยูนิตผู้เล่นโจมตีรวม ${playerAtk} หน่วย!`);
        await dealBoardDamage(bot.board, playerAtk);
    }
    await delay(300);

    // Bot's thorns reflect
    const botThornsDamage = bot.board.filter(u => u.hp > 0 && u.thorns > 0).reduce((sum, u) => sum + u.thorns, 0);
    if (botThornsDamage > 0 && player.board.length > 0) {
        log(`เกราะหนามของบอทสะท้อนความเสียหาย ${botThornsDamage} หน่วย!`);
        await dealBoardDamage(player.board, botThornsDamage);
    }
    await delay(300);

    // Bot attacks player's board
    if (botAtk > 0 && player.board.length > 0) {
        log(`ยูนิตบอทโจมตีรวม ${botAtk} หน่วย!`);
        await dealBoardDamage(player.board, botAtk);
    }
    await delay(300);
    
    // Player's thorns reflect
    const playerThornsDamage = player.board.filter(u => u.hp > 0 && u.thorns > 0).reduce((sum, u) => sum + u.thorns, 0);
    if (playerThornsDamage > 0 && bot.board.length > 0) {
        log(`เกราะหนามของผู้เล่นสะท้อนความเสียหาย ${playerThornsDamage} หน่วย!`);
        await dealBoardDamage(bot.board, playerThornsDamage);
    }
    
    await delay(500);
    cleanupBoards();
    await delay(200);

    // Hero damage calculation
    let damageToBotHero = playerAtk;
    let damageToPlayerHero = botAtk;

    if (player.passed && damageToPlayerHero > 0) {
        damageToPlayerHero = Math.ceil(damageToPlayerHero / 2);
        log("ผู้เล่นรับความเสียหายเพียงครึ่งเดียว!");
    }
    if (bot.passed && damageToBotHero > 0) {
        damageToBotHero = Math.ceil(damageToBotHero / 2);
        log("บอทรับความเสียหายเพียงครึ่งเดียว!");
    }

    if (damageToBotHero > 0) dealDamage(bot, damageToBotHero);
    if (damageToPlayerHero > 0) dealDamage(player, damageToPlayerHero);

    await delay(500);
    log("--- จบเฟสต่อสู้ ---");
    
    game.isCombatting = false;
    if(game.turn !== -1) nextTurn();
}


function cleanupBoards(){
  game.player.board = game.player.board.filter(u=>u.hp > 0);
  game.bot.board = game.bot.board.filter(u=>u.hp > 0);
  render();
}

function nextTurn(){
  game.turn++;
  const isPlayerTurn = game.turn % 2 === 0;
  const currentSide = isPlayerTurn ? game.player : game.bot;

  if (currentSide.isSkipped) {
      log(`${currentSide.name} ถูกข้ามเทิร์น!`);
      currentSide.isSkipped = false;
      render();
      setTimeout(nextTurn, 1000);
      return;
  }

  currentSide.maxMana = Math.min(10, currentSide.maxMana + 1);
  currentSide.mana = currentSide.maxMana;
  draw(isPlayerTurn ? 'player' : 'bot');
  log(`--- เทิร์นของ ${currentSide.name} (มานา: ${currentSide.mana}/${currentSide.maxMana}) ---`);
  
  if (!isPlayerTurn) {
    setTimeout(botTurn, 1500);
  }
  render();
}

function botTurn(){
  const { bot, player } = game;

  // Healing strategy
  const healCardInfo = bot.hand.map((c, i) => ({card: c, index: i})).find(x => x.card.effect === 'heal' && x.card.cost <= bot.mana);
  if (healCardInfo && bot.hp <= (30 - healCardInfo.card.power)) {
      playCard('bot', healCardInfo.index);
      setTimeout(botTurn, 1000);
      return;
  }

  // Pass Turn strategy
  const canPlayCreature = bot.hand.some(c => c.type === 'creature' && c.cost <= bot.mana);
  if (!canPlayCreature && player.board.length > 0 && bot.turnCount > 0) {
      log("บอทเลือกที่จะผ่านเทิร์น");
      bot.passed = true;
      bot.turnCount--;
      draw('bot');
      startCombat();
      return;
  }

  // All-in strategy
  if (bot.hp <= 10 && player.board.length > 0) {
      const affordableCreatures = bot.hand.map((c, i) => ({card: c, index: i})).filter(x => x.card.type === 'creature' && x.card.cost <= bot.mana);
      if (affordableCreatures.length > 0) {
          log("บอทเข้าสู่โหมดโจมตีเต็มกำลัง!");
          playCard('bot', affordableCreatures[0].index);
          setTimeout(botTurn, 1000);
          return;
      }
  }
  
  // Standard play strategy
  let playable = bot.hand.map((c, i) => ({card: c, index: i})).filter(x => x.card.cost <= bot.mana).sort((a,b) => b.card.cost - a.card.cost);
  
  if (playable.length > 0) {
      playCard("bot", playable[0].index);
      setTimeout(botTurn, 1000);
  } else {
      log("บอทจบเทิร์น");
      bot.passed = false;
      if (bot.turnCount > 0) bot.turnCount--;
      startCombat();
  }
}


function randomChoice(arr){ return arr[Math.floor(Math.random() * arr.length)]; }

function checkWinner(){
  if (game.turn === -1) return;
  let gameOver = false;
  let winner = null;

  if(game.player.hp <= 0) winner = game.bot.name;
  if(game.bot.hp <= 0) winner = game.player.name;
  
  if (game.player.turnCount <= 0 && game.bot.turnCount <= 0 && !winner) {
      if (game.player.hp > game.bot.hp) winner = game.player.name;
      else if (game.bot.hp > game.player.hp) winner = game.bot.name;
      else winner = "เสมอ";
  }

  if (winner) {
      if (winner === "เสมอ") log("เกมจบลงด้วยผลเสมอ!");
      else if (winner === game.player.name) log("ยินดีด้วย, คุณชนะ!");
      else log("คุณแพ้แล้ว!");
      
      setTimeout(() => alert(winner === "เสมอ" ? "เสมอ!" : `${winner} เป็นฝ่ายชนะ!`), 100);
      game.turn = -1;
      gameOver = true;
  }

  if (gameOver) {
      document.getElementById('btnNew').style.display = 'block';
      ['btnEndTurn', 'btnPassTurn', 'btnDrawCard'].forEach(id => document.getElementById(id).style.display = 'none');
  }
}

// --- RENDER FUNCTIONS ---
function render(){
  if (!game) return;
  const isPlayerTurn = game.turn % 2 === 0;
  document.getElementById('btnEndTurn').disabled = !isPlayerTurn || game.isCombatting || game.player.turnCount <= 0;
  document.getElementById('btnPassTurn').disabled = !isPlayerTurn || game.isCombatting || game.player.turnCount <= 0;
  document.getElementById('btnDrawCard').disabled = !isPlayerTurn || game.isCombatting || game.player.mana < 3;
  renderHero('player', '🧑‍🚀');
  renderHero('bot', '🤖');
  renderHand('player');
  renderHand('bot');
  renderDeck('player');
  renderDeck('bot');
  renderBoard();
  renderLog();
}

function renderHero(side, icon) {
    const s = game[side];
    const el = document.getElementById(`${side}-hero`);
    el.innerHTML = `
        <div id="${s.id}" class="hero-portrait">${icon}</div>
        <div class="hero-stats">
            <span>❤️ ${s.hp}</span>
            <span>🛡️ ${s.armor}</span>
            <span>💧 ${s.mana}/${s.maxMana}</span>
            <span>⏳ ${s.turnCount}</span>
        </div>`;
}

function renderHand(side) {
    const s = game[side];
    const handEl = document.getElementById(`${side}-hand`);
    handEl.innerHTML = '';
    
    if (side === 'player') {
        s.hand.forEach((c, idx) => {
            const div = document.createElement("div");
            div.className = "card";
            div.innerHTML = getCardHTML(c);
            
            if (s.mana >= c.cost && game.turn % 2 === 0 && !game.isCombatting) {
                div.onclick = () => playCard("player", idx);
            } else {
                div.classList.add("unplayable");
            }
            handEl.appendChild(div);
        });
    } else {
        for (let i = 0; i < s.hand.length; i++) {
            const div = document.createElement("div");
            div.className = "card-back";
            handEl.appendChild(div);
        }
    }
}

function renderDeck(side) {
    const s = game[side];
    const deckEl = document.getElementById(`${side}-deck`);
    if (s.deck.length > 0) {
        deckEl.innerHTML = `<div class="card-back"><div class="card-count">${s.deck.length}</div></div>`;
    } else {
        deckEl.innerHTML = '';
    }
}

function renderBoard() {
    ['player', 'bot'].forEach(side => {
        const boardEl = document.getElementById(`${side}Board`);
        boardEl.innerHTML = '';
        game[side].board.forEach(u => {
            const d = document.createElement("div");
            d.id = u.uid;
            d.className = "card";
            d.innerHTML = getCardHTML(u);
            boardEl.appendChild(d);
        });
    });
}

function getCardHTML(c) {
    let content = `<div class="card-cost">${c.cost}</div>
                      <div class="card-name">${c.name}</div>`;
                      
    if (c.type === 'creature') {
        const hpDisplay = c.maxHp ? `${c.hp}/${c.maxHp}` : c.hp;
        let statsHTML = ``;
        if (c.thorns) statsHTML += `<span>🌵 ${c.thorns}</span>`
        statsHTML += `<span>⚔️ ${c.atk}</span>`;
        if (c.armor > 0) statsHTML += `<span>🛡️ ${c.armor}</span>`;
        statsHTML += `<span>❤️ ${hpDisplay}</span>`;
        
        content += `<div class="card-stats">${statsHTML}</div>`;
        if (c.desc) content += `<div class="card-desc">${c.desc}</div>`;

    } else if (c.type === 'spell') {
      content += `<div class="card-desc">${c.desc}</div>`;
    }
    return content;
}

function renderLog(){
  const lg = document.getElementById("log"); 
  lg.innerHTML = "";
  if (game && game.log) {
    game.log.slice().reverse().forEach(l => {
        const d = document.createElement("div"); 
        d.innerText = `> ${l}`; 
        lg.appendChild(d);
    });
  }
  lg.scrollTop = 0;
}

function log(msg){ 
    if(game) {
        game.log.push(msg); 
        renderLog();
    }
}

document.addEventListener('DOMContentLoaded', () => {
    log("กด 'เริ่มเกมใหม่' เพื่อเล่น");
    ['btnEndTurn', 'btnPassTurn', 'btnDrawCard'].forEach(id => document.getElementById(id).style.display = 'none');
    renderLog();
});

</script>
</body>
</html>

